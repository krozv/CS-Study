# List Collections

## Array

### Array 장점

- 데이터 크기가 정해져있을 경우 메모리 관리가 편리하다.
- 메모리에 연속적으로 나열되어 할당되기 때문에 인덱스를 통한 색인 속도가 빠르다.

### Array 단점

- 인덱스에 위치한 하나의 데이터를 삭제하더라도 해당 인덱스에는 빈공간으로 계속 남는다.
- 처음 선언한 배열의 크기는 변경할 수 없다. (= 정적 할당)
- 배열의 크기를 변경할 수 없기 때문에 너무 큰 크기로 설정하면 메모리 낭비가, 너무 작은 크기로 설정하면 공간 부족 문제가 발생할 수 있다.

<br>

## ArrayList

    배열 기반의 리스트로 메모리 공간을 연속적으로 사용

### 특징

- 연속적인 데이터의 리스트
- 내부적으로 `Object[]` 배열을 이용하여 요소를 저장
- 배열을 이용하기 때문에 **인덱스를 이용해 요소에 빠르게 접근**할 수 있다.
- 크키가 고정되어 있는 배열과 달리 데이터 **적재량에 따라 가변적으로 공간을 늘리거나 줄인다.**
- **배열 공간이 꽉 찰 때마다 배열을 copy하는 방식**으로 늘리므로 이 과정에서 지연이 발생한다.
- 데이터를 리스트 중간에 삽입/삭제할 경우, 중간에 빈 공간이 생기지 않도록 **요소들의 위치를 앞뒤로 자동으로 이동시킨다.**

### ArrayList 장점

- 리스트의 길이가 가변적이다. (= 동적 할당)
- 데이터 사이에 빈 공간을 허용하지 않는다.

### ArrayList 단점

- 배열과 달리 메모리에 연속적으로 나열되어있지 않고 주소로 연결되어 있는 형태이기 때문에 인덱스를 통한 색인 속도가 배열보다 느리다.
- 객체로 데이터를 다루기 때문에 적은 양의 데이터만 쓸 경우 배열에 비해 차지하는 메모리가 커진다.

  > primitive type인 int 타입일 경우 크기는 4Byte이다.  
  > 반면, Wrapper 클래스인 Integer은 JVM 환경에서 최소 16Byte 크기를 차지한다.  
  > 또한 이러한 객체 데이터들을 다시 주소로 연결하기 때문에 `16+a` 바이트를 차지하게 된다.

<br>

## LinkedList

- ArrayList와 같이 인덱스로 접근하여 조회/삽입이 가능하지만 내부 구조는 완전히 다르게 구성되어 있다.
- 노드끼리의 주소 포인터를 서로 가리키며 링크(참조)하므로써 이어지는 구조
- 노드마다 객체의 주소를 서로 참조함으로써 연결 형태를 구성

### 종류

#### 단방향 연결 리스트(Singly Linked List)

    다음 노드를 가리키기 위한 포인터 필드 next만 가지고 있는 linked list
    현재 요소에서 이전 요소로 접근해야 할 때 매우 부적합

#### 양방향 연결 리스트(Doubly Linked List)

    기존 단일 연결 노드에서 이전 노드 주소를 담고 잇는 필드 prev가 추가된 형태
    Java 컬렉션의 LinkedList 클래스가 양방향 연결 리스트로 구현되어 있다.

#### 양방향 원형 연결 리스트(Doubly Circular Linked List)

    첫 번째 노드와 마지막 노드를 각각 연결시켜 마치 원형 리스트처럼 구성한 형태
    티비 채널 순회와 같이 데이터를 순차적 방식으로 처리하다 마지막 요소에서 다시 처음 요소로 되돌아가는 애플리케이션에서 사용

### 장점

- 자료의 삽입과 삭제가 용이
- 리스트 내에서 자료의 이동이 불필요
- 사용 후 기억 장소의 재사용이 가능
- 연속적인 기억 장소의 할당이 불필요

### 단점

- 포인터의 사용으로 인해 저장 공간의 낭비
- 알고리즘 복잡
- 특정 자료의 탐색 시간이 많이 소요

<br>

## ArrayList vs LinkedList

- ArrayList는 배열 기반이고, LinkedList는 노드를 연결하여 구성되어 있다.
- ArrayList는 공간이 부족할 경우 새로운 배열에 복사하는 추가 시간이 발생하지만, LinkedList는 리사이징이 불필요하다.
- ArrayList는 캐시 이점을 활용하지만, LinkedList는 아니다.
