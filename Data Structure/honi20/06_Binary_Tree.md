# Binary Tree

    모든 노드들이 둘 이하의 자식을 가진 트리

<br>

## 유형

#### 전 이진 트리(Full Binary Tree)

    모든 노드가 0개 또는 2개의 자식 노드를 갖는 트리

#### 완전 이진 트리(Complete Binary Tree)

    마지막 레벨을 제외하고 모든 레벨이 완전히 채워져 있는 트리
    마지막 레벨은 노드가 왼쪽에서 오른쪽으로 채워진다.

#### 포화 이진 트리(Perfect Binary Tree)

    모든 내부 노드가 2개의 자식 노드를 가지며 모든 리프 노드가 동일한 레벨을 갖는다.

#### 균형 이진 트리(Balanced Binary Tree)

    왼쪽과 오른쪽 트리의 높이 차이가 모두 1만큼 나는 트리
    (AVL 및 Red-Black 트리)

<br>

## 속성

#### 1. {레벨 l에서 노드의 최대 수} = 2^l

#### 2. 높이가 h인 이진 트리의 최대 노드 수

- root node의 depth가 0인 경우 => 2^(h+1) - 1
- root node의 depth가 1인 경우 => 2^h - 1

#### 3. 리프 노드의 최소 높이

- leaf node의 height가 0인 경우 => log_2\_(N+1) - 1
- leaf node의 height가 1인 경우 => log_2\_(N+1)

<br>

## 구현

### 1. 배열로 구현

- 루트 노드의 인덱스가 1인 경우
- 노드 i의 왼쪽 자식 = 2\*i번 노드
- 노드 i의 오른쪽 자식 = 2\*i+1번 노드
- 노드 i의 부모 = i/2번 노드

#### 장점

- 빠른 노드 접근
- 구현 용이

#### 단점

- 편향 이진 트리 같은 경우, 많은 공간이 낭비
- 배열 크기 이상의 노드 추가 불가능

<br>

### 2. 연결 리스트로 구현

- 포인터를 사용하여 구현

```java
class BinaryTreeNode {
	int data;
	BinaryTreeNode left;
	BinaryTreeNode right;
}
```

#### 장점

- 삽입/삭제가 쉬움
- 노드를 포인터로 연결하기 때문에 노드 수에 제한이 없음

#### 단점

- 배열에 비해 접근 속도가 느림
