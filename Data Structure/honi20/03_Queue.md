# Queue

- 먼저 들어온 것이 먼저 나가는 선입선출 구조
- FIFO(First-In-First-Out) 구조
- front : 삭제 연산이 수행되는 곳
- rear : 삽입 연산이 이루어지는 곳

## 큐의 사용 사례

- 그래프의 넓이 우선 탐색(BFS)
- 대기열 순서와 같은 우선순위의 작업 예약
- 서비스 센터의 대기 시간
- 프로세스 관리

<br>

## Deque

- 양쪽으로 넣고 빼는 것이 가능한 큐
- 스택과 큐를 하나로 합쳐놓은 것과 같으며 스택으로 사용할 수도 있고, 큐로 사용할 수도 있다.
- Java Collections에서 **Deque** 인터페이스의 조상은 **Queue** 인터페이스이며, 구현체로 **ArrayDeque**와 **LinkedList** 등이 있다.

### 장점

- 양방향 연산
- 큐와 스택의 기능을 모두 대체 가능
- 삽입과 삭제가 O(1) 시간복잡도로 수행

### 단점

- 순차 접근이 비효율적
- 특정 위치의 데이터 접근은 느림
- 동적 배열 기반 구현 시 크기 조정 비용 발생 가능

### 응용 사례

- 슬리아딩 윈도우
- 회문 검사(문자열이 앞뒤로 같은지 확인)
- 스케줄링
- BFS
- Undo/Redo

<br>

## OS Scheduler와 Queue

- OS에서 프로세스를 스케줄링하기 위해 Queue가 사용되며, 크게 3개의 Queue가 존재한다.

1. 작업 큐(Job Queue)
   보조 기억 장치에 있는 프로세스가 주 메모리로 적재되기 위해 보조 기억 장치에서 주 메모리의 할당 순서를 기다리는 큐

2. 준비 큐(Ready Queue)
   메모리 내에 있으면서 CPU를 할당받기 위해 기다리고 있는 프로세스들이 모여있는 큐. 즉, CPU 점유 순서를 기다리는 큐

3. 장치 큐(Device Queue)
   I/O 작업을 위해 대기하고 있는 프로세스들의 집합으로, I/O 작업을 위한 각 장치마다 장치를 기다리고 있는 큐가 존재한다.

<br>

## Java Collections - ArrayDeque

- 스택으로 사용할 때 Stack 클래스보다 빠르며, 대기열로 사용할 때는 LinkedList보다 빠르다.
- 사이즈에 제한이 없다.
- null 요소는 저장되지 않는다.

| Deque       | Queue   | Stack  |
| ----------- | ------- | ------ |
| offerLast() | offer() | push() |
| pollLast()  | -       | pop()  |
| pollFirst() | poll()  | -      |
| peekFirst() | peek()  | -      |
| peekLast()  | -       | peek() |
