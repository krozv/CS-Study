# Operating System

## Contents

### Operating System 1

- 운영체제 개요
- 컴퓨터시스템의 구조
- 프로세스 관리
- CPU 스케줄링
- 병행 제어

### Operating System 2

- 데드락
- 메모리 관리
- 가상 메모리
- 파일시스템
- 입출력 시스템

## Questions

[참고1](https://hoons-dev.tistory.com/95)  
[참고2](https://suhyunsim.github.io/2023-03-14/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EB%A9%B4%EC%A0%91%EC%A7%88%EB%AC%B8)

## 운영체제 개요

### 1. 운영체제란?

> 운영체제란 컴퓨터 하드웨어 바로 위에 설치되어 사용자 및 다른 모든 소프트웨어와 하드웨어를 연결하는 소프트웨어 계층입니다.

#### 운영체제의 목적은?

> 컴퓨터 시스템을 편리하게 사용할 수 있는 환경을 제공하고, 컴퓨터 시스템의 자원을 효율적으로 관리하는 목적을 가지고 있습니다.

<br>

## 컴퓨터시스템의 구조

### 1. 메모리 구조에 대해 설명해주세요.

> 메모리 구조는 코드, 데이터, 스택, 힙 영역으로 나뉩니다.
>
> 코드 영역은 함수, 제어문, 상수 등 실행 파일을 구성하는 명령어들이 올라가는 영역입니다.  
> 데이터 영역은 전역 변수와 정적 변수가 할당되는 영역입니다.  
> 스택 영역은 함수 호출 시 생성되는 지역 변수와 매개 변수가 저장되는 영역입니다.  
> 힙 영역은 참조형 데이터 타입을 갖는 객체, 배열 등이 저장되는 공간입니다.

#### 메모리의 힙 영역과 스택 영역의 차이점

> 힙 영역은 사용자에 의해 메모리 공간이 동적으로 할당되고 해제되기 때문에 런타임 시 크기가 결정됩니다. 메모리의 낮은 주소부터 할당되는 선입선출 구조를 가집니다.
>
> 스택 영역은 프로그램이 컴파일 타임에 크기가 결정됩니다. 메모리의 높은 주소부터 할당되는 후입선출 구조를 가집니다.

#### 메모리의 힙 영역을 크게 잡을 때 생기는 문제점

> 응용 프로그램이 종료될 때까지 메모리가 유지되기 때문에 사용하고 난 후 반드시 메모리 해제를 해주어야 합니다. 만약 메모리 힙 영역이 크다면, 넓은 힙 영역에 존재하는 동적 변수에 대해 참조 여부를 확인해야 하기 때문에 Garbage Collection 수행 시간이 너무 길어지는 문제가 발생합니다.

#### 가비지 컬렉션이란

> 메모리 관리 기법 중 하나로, 동적 할당된 메모리 영역 가운데 더 이상 사용할 수 없게 된 영역을 탐지하여 자동으로 해제하는 기법입니다.

### 2. 커널이란?

> 커널이란 OS의 핵심 부분으로 사용자와 실행 프로그램을 위해 매우 빈번하게 사용되는 부분입니다. 컴퓨터 처음 부팅 시 주기억 장치에 적재되고, 시스템의 운영이 종료될 때까지 주기억장치에 남아있습니다.

### 3. 인터럽트란?

> 인터럽트란 프로세스 실행 도중 예기치 않은 상황이 발생할 때 발생한 상황을 처리한 후 실행 중인 작업으로 복귀하는 것을 의미합니다.
>
> 하드웨어 인터럽트란 통상적인 인터럽트로, 컨트롤러 등 하드웨어 장치가 발생시킨 인터럽트입니다.  
> 소프트웨어 인터럽트란 트랩이라고도 불리며, 주로 Exception이나 System Call과 같은 상황에서 발생하는 인터럽트입니다.

### 4. 시스템 콜이란?

> 시스템 콜이란 사용자 프로그램이 OS의 서비스를 받기 위해 커널 함수를 호출하는 것입니다.

### 5. DMA란?

> DMA란 빠른 입출력 장치를 메모리에 가까운 속도로 처리하기 위해 사용하는 방식입니다. CPU의 중재 없이 디바이스 컨트롤러가 디바이스의 버퍼 스토리지의 내용을 메모리에 블록 단위로 직접 전송합니다.

<br>

## 프로세스 관리

### 1. Process와 Thread란?

> 프로세스는 메모리에 적재되어 실행되는 프로그램입니다. PCB, code, data, heap, stack 영역을 갖습니다.
>
> 스레드는 프로세스 내부에서 동작하는 흐름의 단위입니다. 별도의 stack 영역만 갖고, 나머지 영역에 대해서는 해당 쓰레드의 프로세스 자원을 공유합니다.

#### 차이점

> 프로세스는 각각의 영역을 갖기 때문에 동기화 작업이 필요하지 않지만, 스레드는 스택 영역 외부의 공유 자원에 대한 접근 시 동기화 작업이 필요합니다.
>
> 프로세스는 한 프로세스에 오류가 생기더라도 다른 프로세스에 영향을 주지 않지만, 스레드는 한 스레드에서 오류가 생기면 프로세스 내의 나머지 스레드에 영향을 줄 수 있습니다.

### 2. 크롬 브라우저에서 한 탭에 오류가 생기더라도, 다른 탭에 영향을 끼치지 않습니다. 그렇다면 각각의 크롬 탭은 프로세스일까요? 쓰레드일까요?

> 크롬 탭은 프로세스입니다. 쓰레드의 경우, 한 쓰레드에서 오류가 발생하면 다른 쓰레드에 영향을 미치는 특성이 있습니다. 그렇기 때문에 다른 탭에 영향을 끼치지 않는다는 점에서 크롬 탭은 프로세스입니다.

### 3. 쓰레드마다 독립적으로 할당하는 2가지는?

> 스레드는 스택 영역과 PC가 독립적으로 할당됩니다.

#### 독립적으로 할당하는 이유는?

> 스택은 지역변수, 매개변수, 리턴 값 등을 저장하는 메모리 공간입니다. 따라서 독립적인 함수 호출을 위해서는 독립적인 스택 메모리 공간이 필요합니다. 스레드는 독립적인 실행 흐름이므로 독립된 스택을 할당해야 합니다.
>
> PC값은 스레드가 실행할 다음 명령어를 나타냅니다. 스레드는 CPU를 할당받았다가 스케줄러에 의해 다시 반환해야 할 수 있습니다. 따라서 처음부터 끝까지 연속적으로 수행되지 못하므로 어느 부분까지 수행했는지 기억할 필요가 있기 때문에 PC 레지스터를 독립적으로 할당해야 합니다.

### 4. Multi-Process와 Multi-Thread란?

> 멀티 프로세스는 OS에서 하나의 응용 프로그램에 대해 동시에 여러 개의 프로세스를 병렬적으로 수행하는 것입니다.
>
> 멀티 스레드는 하나의 프로세스 안에 여러 개의 스레드가 존재하여 자원을 공유하며 작업을 수행하는 것입니다.

#### 장단점

> 멀티 프로세스는 다른 프로세스에 영향을 주지 않는다는 안전성과 시스템 확장성이라는 장점이 있습니다. 하지만 컨텍스트 스위칭 오버해드가 발생할 수 있다는 점과 자원 공유가 비효율적이라는 단점이 존재합니다.
>
> 멀티 쓰레드는 스레드 간 자원을 공유한다는 자원 효율성이 좋고, 컨텍스트 스위칭 비용이 낮다는 장점이 있습니다. 하지만 다른 스레드에 영향을 받는다는 안정성 문제가 존재하고, 동기화로 인한 병목현상으로 성능이 저하될 가능성이 높다는 단점이 있습니다.

#### 언제 사용되는지

> 독립적 메모리와 안정적인 운영이 필요한 경우 멀티 프로세스가 유리합니다. 예를 들어, 아파치 웹 서버나 MySQL 데이터베이스 서버에서는 각 클라이언트 요청을 독립적인 프로세스로 처리합니다.
>
> 메모리 공유가 필요하고 간단한 작업인 경우 멀티 스레드가 유리합니다. 예를 들어, Tomcat, Node.js는 각 클라이언트 요청을 별도의 스레드로 처리합니다.

### 5. 멀티 프로세싱과 멀티 프로그래밍이란?

> 멀티 프로세싱은 다수의 프로세서가 하나의 응용 프로그램을 병렬로 실행해서 속도를 높이는 기법을 의미합니다. 이때 프로세서는 CPU나 마이크로프로세서와 같은 하드웨어를 의미합니다.
>
> 멀티 프로그래밍은 하나의 프로세서에서 여러 개의 프로그램이 동시에 실행해서 CPU 사용률을 극대화하는 기법을 의미합니다.

### 6. Context Switching이란?

> 컨텍스트 스위칭이란 CPU를 한 프로세스에서 다른 프로세스로 넘겨주는 과정입니다. 현재 진행하고 있는 프로세스의 상태를 PCB에 저장하고, 다음 진행할 프로세스의 정보를 PCB에서 읽어 적용하는 과정입니다.

#### 필요한 이유

> CPU는 한 번에 하나의 프로세스만 수행할 수 있습니다. 하지만 실생활에서 사용자는 여러 개의 프로세스를 동시에 수행하려고 합니다. 그렇기 때문에 CPU는 동시에 수행하는 것처럼 보이게 하기 위해서 여러 개의 프로세스를 번갈아가며 수행합니다. 이때 CPU가 프로세스를 바꿔가며 실행하기 위해서 문맥 교환이 필요합니다.

### 7. PCB란?

> PCB는 운영체제에서 프로세스를 관리하기 위해 해당 프로세스의 상태 정보를 담고 있는 자료구조입니다.  
> 프로세스를 컨텍스트 스위칭 할때 기존 프로세스의 상태를 어딘가에 저장해 둬야 다음에 똑같은 작업을 이어서 할 수 있을 것이고, 새로 해야 할 작업의 상태 또한 알아야 어디서부터 다시 작업을 시작할지 결정하기 위해 PCB를 사용합니다.

### 8. Thread-Safe란?

> 스레드 세이프란 멀티 스레딩 환경에서 여러 스레드가 동시에 같은 코드 영역에 접근하거나 데이터를 공유할 때, 올바른 실행 결과를 보장하는 코드의 속성을 의미합니다. 이는 데이터 무결성과 일관성을 유지하는데 필수적인 조건입니다. 스레드 세이프를 보장하기 위해 상호 배제, 동기화 기법 등을 사용합니다.

### 9. 멀티 쓰레드 환경에서 주의해야 할 점은?

> 다수의 스레드가 공유 데이터에 동시에 접근하는 경우에 상호배제, 동기화 기법을 통한 동시성 문제, 교착 상태가 발생하지 않도록 주의해야 합니다.

### 10. Sync와 Async의 차이점은?

> 동기는 작업이 순차적으로 진행되는 것을 의미합니다. 한 작업이 시작되면 해당 작업이 완료될 때까지 다른 작업은 기다려야 합니다. 동기 방식은 순차적으로 실행되어야 하는 작업이나 작업 간의 의존성이 높은 경우에 적합합니다.
>
> 비동기는 작업이 독립적으로 실행되며, 작업의 완료 여부를 기다리지 않고 다른 작업을 실행할 수 있는 방식을 의미합니다. 비동기 방식은 주로 입출력 작업이나 네트워크 요청과 같이 시간이 오래 걸리는 작업에 유용합니다.

### 11. Blocking과 Non-Blocking의 차이점은?

> 블로킹은 호출된 함수가 자신의 작업이 종료될 때까지 제어권을 갖고 있는 방식입니다. 호출된 함수의 작업이 종료될 때까지 호출하는 함수는 다른 작업을 진행할 수 없습니다.
>
> 논블로킹은 호출된 함수가 자신의 작업이 종료되지 않았더라도 함수의 제어권을 자신을 호출하는 함수에게 바로 넘겨주는 것을 의미합니다.

### 12. 프로세스의 종류에는 무엇이 있는지 설명해주세요.

> 프로세스의 종류로는 부모 프로세스, 자식 프로세스, 데몬 프로세스, 고아 프로세스, 좀비 프로세스가 있습니다.
>
> 부모 프로세스란 자식 프로세스를 만드는 프로세스입니다.  
> 자식 프로세스란 부모에 의해 생성된 프로세스입니다.  
> 데몬 프로세스란 유닉스 커널에 의해 실행되는 프로세스로, 대기 상태로 서비스 요청을 기다리다가 서비스 요청이 들어오면 해당 서비스를 제공합니다.  
> 고아 프로세스란 실행 도중 부모 프로세스가 종료된 프로세스입니다.  
> 좀비 프로세스란 부모 프로세스가 종료처리를 하지 않은 프로세스입니다.

### 13. 동시성과 병렬성의 차이는?

> 동시성은 하나의 시스템이 여러 작업을 동시에 처리하는 것처럼 보이게 하는 것입니다. 즉, 실질적으로는 한 번에 하나의 작업만 처리합니다. 병렬성은 여러 작업을 실제로 동시에 처리하는 것입니다.
>
> 동시성은 싱글 코어에서 멀티 쓰레드를 동작시키는 방식이라면, 병렬성은 멀티 코어에서 멀티 쓰레드를 동작시키는 방식입니다.

<br>

## CPU 스케줄링

### 1. CPU Scheduling이란?

> CPU 스케줄링이란 ready queue에 대기하는 프로세스 중 누구에게 CPU를 줄 것인가를 결정하는 작업입니다. 비선점형 스케줄링과 선점형 스케줄링이 존재합니다.

#### CPU Scheduling 알고리즘 종류

> FCFS는 비선점 스케줄링 알고리즘으로, 먼저 온 순서대로 처리하는 방식입니다. 어떤 프로세스가 먼저 실행되느냐에 따라 전체 대기 시간에 상당한 영향을 미칩니다.
>
> SJF는 비선점 스케줄링 알고리즘으로, CPU burst가 가장 짧은 프로세스에게 먼저 CPU를 할당하는 방식입니다. 평균 대기 시간을 가장 짧게 하는 최적의 알고리즘입니다.
>
> SRTF는 선점 스케줄링 알고리즘으로, CPU burst가 가장 짧은 프로세스에게 먼저 CPU를 할당하는 방식입니다. CPU를 잡았더라도 더 짧은 프로세스가 들어오면 CPU를 빼앗기게 됩니다.
>
> Round Robin은 선점 스케줄링 알고리즘으로, 각 프로세스에 동일한 크기의 할당 시간을 제공하는 방식입니다. 할당 시간이 지나면 프로세스는 CPU를 빼앗기고 레디 큐 맨 뒤에 가기 때문에 짧은 응답 시간을 보장합니다.

### 2. CPU의 성능 척도에 무엇이 있는가?

> CPU 성능 척도는 크게 시스템 입장과 프로세스 입장으로 나뉩니다.  
> 시스템 입장에서는 CPU 이용률과 처리량이 성능의 척도를 나타냅니다.  
> 프로세스 입장에서는 소요시간 및 반환시간, 대기 시간, 응답 시간이 성능의 척도를 나타냅니다.

### 3. preemption과 non-preemption의 차이점은?

> 선점형 스케줄링은 하나의 프로세스가 CPU를 차지하고 있을 때, 우선 순위가 높은 다른 프로세스가 현재 프로세스를 중단시키고 CPU를 점유하는 스케줄링 방식입니다.
>
> 비선점형 스케줄링은 하나의 프로세스가 CPU를 할당 받으면, 작업 종료 후 CPU 반환 시까지 다른 프로세스가 CPU를 점유할 수 없는 스케줄링 방식입니다.

### 4. Convoy Effect란?

> 콘보이 현상이란 긴 프로세스 하나 때문에 짧은 프로세스 여러 개가 기다리는 현상입니다. 주로 FCFS 스케줄링에서 발생하는 문제점입니다.

### 5. 운영체제에서 기아란?

> 기아란 자신보다 우선순위 높은 프로세스 때문에 오랫동안 cpu 할당을 받지 못하는 현상입니다.

### 6. 운영체제에서 에이징이란?

> 에이징이란 아무리 우선 순위가 낮은 프로세스라 하더라도 시간이 오래 지나면 우선 순위를 높여주는 기법입니다.

<br>

## 병행 제어

### 1. Race Condition과 Critical Section이란?

> race condition이란 공유 자원을 둘 이상의 스레드 혹은 프로세스가 읽거나 쓰면서 결과값이 의도와 달라질 수 있는 문제입니다. 예측 불가능한 결과, 일관성 손실, 디버깅의 어려움, 잠금 대기 시간 등의 문제점이 존재합니다.
>
> critical section이란 공유되는 자원, 즉 동시접근하려고 하는 그 자원에서 문제가 발생하지 않게 독점을 보장해주는 영역입니다.

### 2. Mutex와 Semaphore란?

> 뮤텍스란 상호배제를 구현하기 위한 동기화 기법 중 하나로, 공유 자원에 대한 접근을 동시에 하나의 스레드만 가능하게 제한합니다.
>
> 세마포어란 멀티 프로그래밍 환경에서 공유된 자원에 대한 접근을 제한하는 방법입니다.

#### 차이점

> 동기화 대상의 갯수 차이가 있습니다. 뮤텍스는 동기화 대상이 1개이고, 세마포어는 동기화 대상이 1개 이상일 때 사용합니다.
> 뮤텍스는 소유하고 있는 스레드만이 이 뮤텍스를 해제할 수 있지만, 세마포어는 세마포어를 소유하지 않은 스레드도 해제가 가능합니다.

### 3. 스풀링이란?

> 특히 다중 프로그래밍 환경에서 다수 프로세스들이 입출력장치를 서로 요구하거나 그 장치의 수가 제한되어 있는 경우 이를 공유하기 위해 가상장치를 각 프로세스에게 제공해주는 개념입니다.

### 4. SpinLock이란?

> 특정한 자료구조를 lock 또는 unlock 함으로써 공유 데이터에 대한 접근 권한을 관리하는 방법입니다. 권한을 획득하기 전까지는 CPU는 무의미한 코드를 수행하는 busy waiting 상태로 대기하고 있다가 접근 권한을 얻는다면 내부 코드를 수행하고 종료 후 권한을 해제합니다.

<br>

## 데드락

### 1. DeadLock이란?

> 데드락이란 둘 이상의 프로세스가 다른 프로세스가 점유하고 있는 자원을 서로 기다릴 때 무한 대기에 빠지는 상황입니다.

#### 교착 상태의 4가지 필요 조건은?

> 교착 상태의 필요 조건은 상호 배제, 비선점, 점유 대기, 순환 대기입니다.
>
> 상호 배제란 매 순간 하나의 프로세스만이 자원을 사용할 수 있다는 의미입니다.  
> 비선점이란 프로세스는 자원을 스스로 내어놓을 뿐 강제로 빼앗가지 않는다는 의미입니다.  
> 점유 대기란 자원을 가진 프로세스가 다른 자원을 기다릴 때 보유 자원을 놓지 않고 계속 가지고 있는다는 의미입니다.  
> 순환 대기란 자원을 기다리는 프로세스 간에 사이클이 형성되어야 한다는 의미입니다.

#### 교착 상태 해결 방법은?

> 교착 상태 해결 방법은 크게 예방, 회피, 탐지 및 회복, 무시가 있습니다.
>
> 예방의 경우는 자원 할당 시 데드락의 4가지 필요 조건 중 어느 하나가 만족되지 않도록 하는 방법입니다.  
> 회피는 자원 요청에 대한 부가적인 정보를 이용해서 데드락의 가능성이 없는 경우에만 자원을 할당하는 방법입니다.  
> 탐지 및 회복은 데드락 발생은 허용하되 그에 대한 탐지 루틴을 두어 데드락 발견 시 회복하는 방법입니다.  
> 무시는 deadlock을 시스템이 책임지지 않고 무시하는 방법입니다.

### 2. Banker's algorithm이란?

> 은행원 알고리즘이란 데드락을 회피하는 방법 중 한가지로 자원의 갯수가 2개 이상인 사이클에서 데드락을 회피할 때 사용하는 알고리즘입니다.  
> 교착 상태가 발생하기 전에 예방할 수 있고, 시스템 향상을 기대할 수 있다는 장점이 존재합니다.  
> 하지만 프로세스의 자원 요청 순서를 변경하지 못할 경우 사용하지 못하고, 항상 safe state를 유지해야 하기 때문에 자원 사용량이 낮아진다는 단점이 존재합니다.

### 3. ['식사하는 철학자 문제'](https://yonghwankim-dev.tistory.com/479)란?

> 식사하는 철학자 문제란 동기화 문제의 대표적인 문제입니다. 5명의 철학자가 원형 식탁에 둘러앉아 생각하기, 밥먹기의 행동을 합니다. 그들의 양쪽엔 각각 젓가락 한 짝씩 놓여있습니다. 밥을 먹기 위해서는 다음의 과정을 거칩니다.  
> 먼저 왼쪽 젓가락부터 집어듭니다. 다른 철학자가 이미 왼쪽 젓가락을 쓰고 있다면 그가 내려놓을 때까지 생각하며 대기합니다.  
> 다음으로 왼쪽을 들었으면 오른쪽 젓가락을 듭니다. 들 수 없다면 1번과 마찬가지로 들 수 있을 때까지 생각하며 대기합니다.  
> 두 젓가락을 모두 들었다면 일정 시간동안 식사를 합니다.  
> 식사를 마쳤으면 오른쪽 젓가락을 내려놓고, 그 다음 왼쪽 젓가락을 내려놓습니다.

#### DeadLock이 어떨 때 발생하는지

> 모든 철학자가 각자의 왼쪽 젓가락을 드는 경우 deadlock이 발생합니다.  
> 5명 모두 자신의 왼쪽 젓가락을 들고 있기 때문에 점유 대기입니다. 남이 젓가락을 뺏어주지 않기 때문에 비선점이고, 서로 오른쪽 젓가락을 놓기만을 기다리기 때문에 순환 대기입니다. 각 젓가락에 대해 한 사람만 들 수 있는 상호 배제입니다.

#### 이를 해결하기 위한 방법

> 첫 번째 방법은 철학자들의 인원수를 젓가락의 개수보다 1명 적게 배치합니다.  
> 두 번째 방법은 철학자들은 두 젓가락을 집을 수 있을때에만 젓가락을 집는 것을 허락합니다.  
> 마지막 방법은 비대칭적인 해결안을 사용하여 홀수의 철학자는 왼쪽에서 오른쪽 순으로, 짝수의 철학자는 오른쪽에서 왼쪽 순으로 젓가락을 집도록 합니다.

<br>

## 메모리 관리

### 1. OS가 메모리 관리를 해야하는 이유는?

> 각각의 프로세스는 독립된 메모리 공간을 갖기 때문에 다른 프로세스의 메모리 공간에 접근할 수 없습니다. 그렇게 때문에 OS 메모리 영역과 사용자 메모리 영역의 접근에 영향을 받지 않는 OS가 메모리에 대한 적절한 관리를 해야합니다.

#### 메모리 관리를 위해 어떤 전략을 사용해야 하는지

> 메모리 관리 전략으로는 가상메모리를 이용한 스와핑, 페이징 및 세그멘테이션, 고정 길이 할당, 가변 길이 할당, 압축 등이 있습니다.

### 2. 메모리 할당 방식 중 연속(Contiguous) 방식과 불연속(Non-Contiguous) 방식이란?

> 연속할당 방식이란 메모리에 연속적으로 프로세스의 공간을 할당하는 것입니다.  
> 연속할당 방식은 고정분할 방식과 가변분할 방식으로 나눌 수 있습니다.  
> 고정분할 방식은 물리적 메모리를 미리 같은 크기로 분할해서 할당하는 방법이고, 가변분할 방식은 프로그램의 크기에 따라 동적으로 할당하는 방식입니다.
>
> 불연속 할당 방식은 메모리를 연속적으로 할당하지 않는 방법으로 현대 OS에서 사용하는 방식입니다.  
> 대표적으로 페이징 방식과 세그멘테이션 기법이 있습니다.

### 3. 메모리 fit의 종류

> First-fit, Best-fit, Worst-fit이 있습니다.  
> First-fit은 크기가 n 이상인 Hole 중 최초로 발견한 Hole에 할당하는 방식입니다.  
> Best-fit은 크기가 n 이상인 가장 작은 Hole을 찾아 할당하는 방식입니다.  
> Worst-fit은 가장 큰 Hole을 찾아 할당하는 방식입니다.

### 4. Swapping이란?

> 스와핑이란 우선순위가 낮은 프로세스를 swap out 시키고, 높은 프로세스를 swap in하는 방식입니다.  
> swap out이란 프로세스를 디스크로 내보내는 것이고, swap in이란 프로세스를 메모리로 들여보내는 것입니다.

#### Swapping 중에 발생하는 문제점

> 스와핑을 하게 된다면 프로세스들이 메모리에 적재되고 제거되는 일이 반복되면 프로세스들이 차지하는 메모리 틈 사이에 사용하지 못할 만큼의 작은 공간들이 늘어나게 되는 현상인 단편화가 발생할 수 있습니다.

### 5. Paging과 Segmentation이란?

> 페이징이란 프로세스를 할당할 때 동일한 크기의 페이지 단위로 나누어 메모리의 서로 다른 위치에 프로세스를 할당하는 방식입니다.
> 세그멘테이션이란 페이지 단위가 아닌 의미 단위인 세그먼트로 나누는 방식입니다. 프로세스는 코드, 데이터, 스택, 힙 영역으로 나누어져 메모리가 할당되는데 이러한 논리적 영역을 세그먼트라고 합니다.

#### 장단점

> 페이징의 장점은 페이지들이 연속할 필요가 없어 외부 단편화를 해결할 수 있다는 점입니다. 할당과 해제가 빠르고, swap out이 간단합니다.  
> 페이징의 단점은 내부 단편화를 해결하지 못하고, page table을 저장하기 위한 메모리가 추가로 필요하다는 점입니다.
>
> 세그멘테이션의 장점은 내부 단편화 문제가 해소되고, 프로그램의 중요한 부분과 중요하지 않은 부분을 분리하여 저장하기 때문에 보호와 공유 기능을 수행할 수 있다는 점입니다.  
> 단점은 외부 단편화 문제가 발생할 수 있다는 점입니다.

### 6. 내부단편화와 외부단편화란?

> 내부 단편화란 프로세스가 사용하는 메모리 공간보다 분할된 공간이 더 커서 메모리가 남는 경우입니다.  
> 외부 단편화란 총 공간을 계산했을 때 프로세스가 들어갈 수 있는 메모리가 있음에도 불구하고 공간들이 연속하지 않아 사용할 수 없는 경우입니다.

### 7. 단편화를 해소하기 위한 방법은?

> 내부 단편화의 해결법으로는 세그멘테이션이 있습니다.
>
> 외부 단편화의 해결법으로는 압축과 페이징이 있습니다.
>
> 내부 단편화와 외부 단편화를 모두 해결하는 방법으로는 메모리 풀이 있습니다. 이는 필요한 메모리 공간을 필요한 크기, 갯수만큼 직접 지정하여 미리 할당받아 놓고 필요할 때마다 사용하고 반납하는 기법입니다. 메모리 할당 및 해제가 잦을 때 효과적입니다.

### 8. DMA란?

> Direct Memory Access로 CPU 개입없이 메모리에 접근하는 기법입니다. CPU의 개입 없이 입출력장치와 같은 주변장치와 메모리 사이의 데이터 전송을 담당합니다.

### 9. 캐시 메모리를 사용하는 이유는?

> 캐시 메모리를 사용하는 이유는 속도가 빠른 장치와 느린 장치 간의 속도차에 따른 병목 현상을 줄이기 위해서 입니다.

<br>

## 가상 메모리

### 1. 가상메모리란?

> 가상 메모리란 OS에서 실제 물리 메모리인 RAM보다 큰 주소 공간을 프로세스에게 제공하기 위해 사용되는 기술입니다.

### 2. 요구 페이징(Demand Paging)이란?

> 요구 페이징이란 프로그램 실행 시작 시 실제로 필요한 페이지만을 메모리에 올리는 것입니다. 이를 통해 CPU 이용률과 처리율이 높아지고, 더 많은 사용자를 수용할 수 있습니다.

### 3. 페이지 교체는 언제 발생하는가?

> 프로세스 동작 중 필요한 페이지가 물리 메모리에 없는 페이지 폴트가 발생하면 원하는 페이지를 디스크에서 swap in하게 됩니다.
> 이때 물리 메모리가 모두 사용 중이어서 원하는 페이지를 적재하지 못할 때 페이지 교체가 발생합니다.

#### 페이지 교체 알고리즘 종류

> 페이지 교체 알고리즘의 종류로는 OPT, FIFO, LRU, LFU, Clock 알고리즘이 존재합니다.
>
> OPT는 가장 먼 미래에 참조되는 페이지를 대체하는 방법입니다.  
> FIFO는 제일 먼저 들어온 페이지를 먼저 내보내는 방법입니다.  
> LRU는 가장 오래 전에 참조된 것을 대체하는 방법입니다.  
> LFU는 참조 횟수가 가장 적은 페이지를 대체하는 방법입니다.  
> Clock 알고리즘은 최근에 참조되었는지 여부를 나타내는 레퍼런스 비트라는 정보를 사용하는 방법입니다.

### 4. Thrashing이란?

> 트레싱이란 프로세스가 원활한 수행에 필요한 최소한의 페이지 프레임을 할당받지 못해서 실행보다 스와핑을 하는데 더 많은 시간을 소모하는 현상입니다.

### 5. 메모리가 고갈되면 발생하는 현상은?

> 메모리가 고갈되면 프로세스 실행을 위한 swap이 활발해집니다. 때문에 CPU 이용률이 감소하고, OS는 CPU 이용률이 낮아 오히려 프로세스를 추가하는 쓰레싱 현상이 발생합니다.
> 이를 해결하지 못하면 Out of Memory 상태로 판단하여 중요도가 낮은 프로세스를 강제 종료하게 됩니다.

<br>

## 입출력 시스템

### 1. [RAID의 종류](https://willseungh0.tistory.com/126)에는 무엇이 있는가?

> RAID는 여러개의 디스크를 묶어 하나의 논리적인 디스크처럼 사용하는 기술입니다. 안정성 확보, 성능 향상, 용량 확장 등의 효과를 갖습니다.
>
> RAID 0은 동일한 디스크 여러 대를 병렬 방식으로 구성하는 방식입니다.  
> RAID 1은 모든 디스크에 데이터를 N개로 복제하여 각 디스크에 저장하는 방식입니다.  
> RAID 2는 RAID 0에서 몇몇 디스크들에 오류 검사 및 수정을 위한 ECC(Error Correcting Code) 정보가 저장되는 방식입니다.  
> RAID 3은 RAID 2에서 여러 개의 패리티 디스크가 아닌 하나의 패리티 드라이브를 구성하는 방식입니다.  
> RAID 4는 RAID 3에서 데이터를 바이트가 아닌 블록 단위로 나누어 디스크에 분산 저장하는 방식입니다.  
> RAID 5는 RAID 4에서 모든 드라이브에 패리티 정보를 분산 저장하는 방식입니다.  
> RAID 6은 RAID 5에서 패리티 정보를 2개의 드라이브에 저장하는 방식입니다.  
> RAID 10은 스트라이핑과 미러링 방식을 혼합해서 구성한 방식입니다.

### 2. 버퍼링이란?

> 버퍼링이란 프로세서와 입출력 장치의 속도 차이로 생긴 유휴시간이 없도록 입출력 장치별로 입출력 버퍼를 두어 프로세서에서 연산을 할 때 동시에 다른 작업을 입출력하는 방법입니다.

#### 스풀링이란?

> 스풀링이란 속도가 빠른 디스크를 버퍼처럼 사용하여 입출력 장치에서 미리 읽는 것입니다.
