# Question

## 운영체제 개요

1. 운영체제란?
    
    컴퓨터의 하드웨어를 관리하고, 응용 프로그램이나 사용자가 컴퓨터를 효율적으로 사용할 수 있도록 지원하는 소프트웨어
    
    a. 운영체제의 목적은?
    
    처리능력 향상, 반환 시간 단축, 사용 가능도 향상, 신뢰도 향상
    

## 컴퓨터시스템의 구조

1. 메모리 구조에 대해 설명해주세요
    
    코드, 데이터, 힙, 스택으로 나뉨
    
    a. 메모리의 힙 영역과 스택 영역의 차이점
    
    힙 영역은 사용자에 의해 동적으로 할당된다
    
    스택 영역은 함수의 호출과 동시에 자동으로 할당됨
    
    b. 메모리의 힙 영역을 크게 잡을 때 생기는 문제점
    
    - 다른 영역(스택)의 메모리 공간이 부족해짐
    - 힙은 동적으로 할당되는 메모리이므로 비용이 증가하고 효율이 떨어질 수 있음

2. 커널이란?
    - 운영체제의 핵심 소프트웨어
    - 프로세스 제어, 메모리 제어, 시스템 콜 등을 수행함

3. 인터럽트란?
    - cpu가 프로그램을 실행 중일 경우 작업을 중지하고 운영체제에게 자원을 할당하는 것

4. 시스템 콜이란?
    - 프로그램이 io 장치 등 운영체제의 자원을 사용하기 위해 요청하는 트랩의 일종(인터럽트의 일종이기도 함)

## 프로세스 관리

1. Process와 Thread란?
    - 프로세스는 실행중인 프로그램으로, 운영 체제의 작업 단위
    - 스레드는 프로세스 내에서 실행되는 작업의 단위
    
    a. 차이점
    
    - 프로세스는 독립적인 메모리 공간이 필요하나, 스레드는 서로 메모리를 공유함
    - 프로세스가 상대적으로 비용이 큼
  
2. 크롬 브라우저에서 한 탭에 오류가 생기더라도, 다른 탭에 영향을 끼치지 않습니다. 그렇다면 각각의 크롬 탭은 프로세스일까요? 쓰레드일까요?
    
    각자 영향을 끼치지 않으므로 프로세스임
    
3. 쓰레드마다 독립적으로 할당하는 2가지는?
    
    스택과 레지스터를 독립적으로 할당
    
    a. 독립적으로 할당하는 이유는?
    
    스택에는 함수, 지역 변수 등이 저장되어 있으며, 레지스터는 현재 작업 상태를 저장하는 것임. 이를 통해 작업 간 충돌을 방지할 수 있음
    
4. Multi-Process와 Multi-Thread란?
    
    멀티 프로세스는 한 컴퓨터에 여러 개의 프로그램이 실행 되는 것을 뜻합니다. 멀티 스레드는 한 프로세스의 PCB 안에 여러 개의 생성해 병렬로 작업을 수행하는 것입니다.
    
    a. 장단점
    
    - 멀티프로세스
        - 장점
            - 하나의 프로세스가 종료되어도 다른 프로세스에 영향을 끼치지 않음
            - 각 프로세스가 독립적인 메모리 공간을 가지므로 충돌이 적음
        - 단점
            - IPC에 많은 시간 소요
            - context switch에 많은 비용 투자
    - 멀티스레드
        - 장점
            - 같은 프로세스 내에서 메모리를 공유하므로 비교적 빠른 작업 속도
            - context switch 비용 절감
        - 단점
            - 하나의 스레드에서 문제가 발생한 경우 해당 프로세스 전체에 영향을 끼칠 수 있음
    
    b. 언제 사용되는지
    
    - 멀티프로세스
        - 독립적인 작업이 필요하거나 안정성이 중요할 경우
    - 멀티스레드
        - 실시간 작업이나 병렬 작업의 경우, 게임같은 경우
  
5. 멀티 프로세싱과 멀티 프로그래밍이란?
    1. 멀티 프로세싱은 한 컴퓨터에서 여러 프로세스를 실행하는 것을 의미함. 주로 멀티코어 시스템에서 사용
    2. 멀티 프로그래밍은 여러 프로그램을 동시에 하나의 메모리에 올려놓고 실행하는 것

6. Context Switching이란?
    
    CPU가 하나의 작업에서 다른 작업으로 전환될때 기존 작업의 상태를 PCB에 저장하고 새 작업의 상태를 불러오는것
    
    a. 필요한 이유
    
    cpu 자원을 최적의 상태에서 사용하기 위함
    
    멀티태스킹을 가능하게 함
    
7. PCB란?
    
    process control block
    
    운영 체제가 프로세스의 정보와 상태를 관리하기 위해 사용하는 자료구조
    
8. Thread-Safe란?
    
    여러 스레드가 동시에 접근해도 데이터의 일관성과 정확성을 보장하는 코드
    
9. 멀티 쓰레드 환경에서 주의해야 할 점은?
    - 여러 스레드가 같은 자원에 접근하면 충돌이 발생할 수 있음
    - Deadlock(교착상태) 발생 가능
        - 서로의 자원을 기다리며 무한 대기에 빠지는 상태

10. Sync와 Async의 차이점은?
    - 동기는 작업이 순차적으로 진행되는 것을 뜻하며, 여러 작업이 완료된 이후에 다음 작업이 실행됨.
    - 비동기는 작업이 비순차적으로 진행되머, 현재 작업이 종료되지 않아도 다음 작업을 진행할 수 있음

11. Blocking과 Non-Blocking의 차이점은?
    - blocking은 작업이 끝날때까지 호출한 함수를 대기 상태에 있게 함(동기)
    - non-blocking은 작업이 끝나지 않아도 호출한 함수를 리턴(비동기)

12. 프로세스의 종류에는 무엇이 있는지 설명해주세요.
    1. 수행역할에 따른
        - 유저 프로세스
            
            사용자 프로그램의 코드를 수행하는 프로세스
            
        - 커널 프로세스
            
            운영체제에 의해 실행되는 프로세스. 프로세스 실행 순서를 제어함
            
    2. 병렬작업에 따른
        - 독립 프로세스
            
            다른 프로세스에 영향을 끼치지 않음
            
        - 협력 프로세스
            
            다른 프로세스와 메모리 공간을 공유하는 프로세스
            
13. 동시성과 병렬성의 차이는?
    - 동시성은 여러 프로세스가 동시에 실행되는 것처럼 보이는 상태로, 시분할을 통해 구현할 수 있음. 그러나 동시에 실행되는 것처럼 보이는 것이지 실제 프로세스는 번갈아가면서 실행됨
    - 병렬성은 실제로 여러 프로세스가 동시에 실행되는 것임. 멀티코어 환경이 필요함

## CPU Scheduling

1. CPU Scheduling이란?
   - CPU를 쓰기 위해 많은 프로세스들이 Ready queue에서 대기하고 있습니다. 이 중 어떤 프로세스에게 CPU를 사용할 수 있도록 할지 결정하는 것을 CPU Scheduling 이라고 합니다.

    1. CPU Scheduling의 종류
        - 총 7가지의 종류가 있습니다.
        1. FCFS (First-Come First-Served)
            - 먼저 온 프로세스부터 CPU를 제공하는 방식입니다.
        2. SJF (Shortest-Job-First)
            - 프로세스의 사용 시간이 짧은 프로세스부터 CPU를 할당하는 방식입니다.
        3. SRTF (Shortest-Remaining-Time-First)
            - SJF에서 preemitive 방식으로 할당할 경우를 뜻합니다.
        4. Priority Scheduling
            - 우선순위가 높은 프로세스에게 CPU를 할당합니다. 
        5. Round Robin
            - 실제 CPU 스케줄링에서 가장 많이 사용하는 방법으로, timer를 사용하여 일정 시간이 만료되면 인터럽트를 사용하여 CPU를 반납하도록 하는 방식입니다.
        6. Multilevel Queue
            - ready queue를 여러 개로 분할하여 프로세스의 종류에 따라 다른 큐에 위치하도록 하는 방식입니다.
        8. Multilevel Feedback Queue
            - 프로세스가 다른 큐로 이동이 가능하며, 각각의 큐에 대한 우선순위를 정하는 기준이 있습니다.

2. CPU의 성능 척도에 무엇이 있는가?
   1. CPU utilization (이용률)
        - 전체 시간 중 CPU가 놀지 않고 일한 비율
   2. Throughput (처리량)
        - 단위 시간 당 CPU의 처리량
   3. Turnaround time (소요시간, 반환시간)
        - CPU 사용 시간 + CPU waiting time
   4. Waiting time (대기 시간)
      - 프로세스의 CPU 대기 시간 총 합
   5. Response time (응답 시간)
        - 프로세스가 CPU를 사용할 때 최초의 기다린 시간

3. preemption과 non-preemption의 차이점은?
   - Nonpreemptive
     - 일단 CPU를 사용 중일 경우 해당 CPU burst가 완료될 때까지 반납하지 않습니다.
   - Preemptive
     - 현재 수행중인 프로세스보다 더 짧은 burst time을 가진 프로세스가 도착하면 CPU 강제반납합니다.

4. Convoy Effect란?
   FCFS 방식에서 CPU 이용시간이 긴 프로세스 뒤에 이용시간이 짧은 프로세스가 오는 경우를 의미합니다.

5. round robin은 CPU 성능 척도 중 무엇을 극대화 시킨 것인가?
   
   Response time을 극대화시킴

### 병행 제어

1. Race Condition과 Critical Section이란?

    - race condition이란 두 개 이상의 프로세스가 shared data를 사용할 경우, 순서에 따라 결과값에 영향을 줄 수 있는 상태를 의미
    - critical section이란 synchronization에서 둘 이상의 프로세스가 동시에 접근해서는 안되는 코드를 의미함

2. 운영체제에서 기아란? (Starvation)
    - 프로세스가 자원을 할당받지 못해 작업을 진행하지 못하는 상태

3. 운영체제에서 에이징이란?
   - 낮은 우선 순위를 가진 프로세스가 일정 시간이 경과함에 따라 우선순위를 점진적으로 높여주는 기법. starvation을 방지하기 위해 사용함

4. Mutex와 Semaphore란?
    - Mutex: mutual exclusion을 위해 사용함. 특정 자원에 대해서 단일 프로세스의 접근만 허용하기 위해 사용하며, locked, unlocked 형태로 사용함
    - Semaphore: critical section에 대한 프로세스의 접근을 제어하기 위해 사용하는 추상 자료형

5. 스풀링이란?
    - 주변 장치가 데이터를 처리할 준비가 될 때까지 데이터를 임시로 저장하는 기술
    - 버퍼링과 스풀링의 차이?
      - 스풀링: 디스크를 버퍼처럼 저장
      - 버퍼링: 버퍼에 저장
      - 둘 다 주변 장치와 컴퓨터 장치 간의 데이터를 전송할 때 처리 지연을 단축시키기 위함

6. SpinLock이란?
   - busy-waiting이라고도 함. 다른 프로세스가 lock를 해제할 때까지 CPU와 메모리를 점유한 상태로 대기 상태를 유지하는 것

### 데드락

1. DeadLock이란?
    - 프로세스들이 서로가 가진 자원을 기다리며 block된 상태

   a. 교착 상태의 4가지 필요 조건은?
   - mutual exclusion
   - no preemption
   - hold and wait
   - circular wait

   b. 교착 상태 해결 방법은?
   - deadlock prevention
   - deadlock avoidance
   - deadlock detection and recovery
   - deadlock ignorance

2. Banker's algorithm이란?
    - 각 프로세스가 필요한 최대 자원을 미리 계산하여, 프로세스에 자원을 할당하기 전에 Safe state인지 계산한다. 안전하지 않으면 자원을 할당하지 않아 교착 상태를 방지할 수 있음

3. '식사하는 철학자 문제'란?
   - 동시성 문제

   a. DeadLock이 어떨 때 발생하는지
    - 철학자가 양쪽 젓가락을 동시에 사용
    - 모든 철학자가 한쪽 젓가락을 잡고 다른쪽 젓가락 대기

   b. 이를 해결하기 위한 방법
    - 4명만 동시에 자리에 앉을 수 있도록 함
    - 젓가락 2개를 모두 잡을 수 있을 때에만 젓가락을 집을 수 있도록 함
    - 짝수 철학자는 왼쪽 젓가락부터 집도록

### 메모리 관리

1. OS가 메모리 관리를 해야하는 이유는?
   - 메모리를 제한된 자원이므로, 여러 프로세스가 메모리를 효율적으로 사용할 수 있도록 관리해야합니다. 또한 각 프로세스가 다른 프로세스의 메모리 공간에 접근하지 않도록 해야합니다.

   a. 메모리 관리를 위해 어떤 전략을 사용해야 하는지
    - paging: 메모리를 고정된 크기의 페이지로 나누어 관리
    - segmentation: 프로세스를 논리적인 세그먼트 단위로 관리
    - swapping: 메모리를 비우기 위하여 프로세스를 임시로 디스크로 내쫓음
    - caching: 자주 사용하는 데이터를 캐시 메모리에 저장

2. 메모리 할당 방식 중 연속(Contiguous) 방식과 불연속(Non-Contiguous) 방식이란?
   - Contiguous Allocation: 프로세스의 메모리 공간이 연속된 주소를 차지합니다.
     - 장점: 메모리 접근 속도가 빠름
     - 단점: 내부 단편화 및 외부 단편화 문제가 발생
   - Non-Contiguous Allocation: 프로세스의 메모리 공간이 물리적으로 연속적이지 않도록 할당합니다. 페이징 및 세그먼테이션 기법이 있습니다.
     - 장점: 단편화 문제 감소
     - 단점: 주소 변환 필요성이 있으며 이에 따라 오버헤드가 증가

3. 메모리 fit의 종류
    - First Fit: 첫 번째로 일치하는 메모리 빈 공간에 할당
    - Best Fit: 프로세스가 들어갈 수 있는 공간 중 가장 작은 빈 공간에 할당
    - Worst Fit: 프로세스가 들어갈 수 있는 공간 중 ㅏ장 큰 공간에 할당

4. Swapping이란?
    - 프로세스를 일시적으로 메모리에서 디스크의 backing store로 이동시켜 공간을 확보하는 것을 의미

   a. Swapping 중에 발생하는 문제점
   - context switching에 따라 시간이 증가
   - 디스크 I/O 오버헤드 발생
   - Trashing 발생

5. Paging과 Segmentation이란?
   - Paging:
      - 메모리를 고정된 크기인 페이지로 나누어 관리하는 불연속 할당 방식
      - 장점: 외부 단편화 없음, 메모리 관리 용이
      - 단점: 내부 단편화 발생 가능
    - Segmentation:
      - 프로세스를 논리적인 세그먼트 단위(Code, Data, Stack)로 나누어 관리하는 불연속 할당 방식
      - 장점: 프로그램의 논리적 구조를 반영, 메모리 공간 낭비를 줄일 수 있으며 보안 및 안정성을 강화할 수 있음
      - 단점: 외부 단편화 발생 가능

6. 내부단편화와 외부단편화란?
   - 내부 단편화
     - 프로세스에 할당된 메모리 공간 중 실제로 사용되지 않는 부분
   - 외부 단편화
     - 사용 가능한 메모리 공간이 존재하지만, 크기가 작아 프로세스를 할당하지 못하는 공간
     - 연속 할당 방식에서 자주 발생함

7. 단편화를 해소하기 위한 방법은?
   - Paging
   - Segmentation
   - Dynamic Memory Allocation: 메모리를 필요할 때만 동적으로 할당함

8. DMA란?
   - DMA (Direct Memory Access)
     - CPU를 거치지 않고 주변 장치가 메모리와 직접 데이터 전송을 수행
     - 장점: CPU 오버헤드가 감소하며 데이터 전송 속도가 향상됨

9.  캐시 메모리를 사용하는 이유는?
    - CPU와 메모리의 속도 차이를 해결할 수 있음
    - 데이터 접근 속도를 향상시킬 수 있음

### 가상 메모리

1. 가상메모리란?
   - 실제 물리적 메모리보다 큰 주소 공간을 사용하는 기술. 디스크의 일부를 마치 메모리처럼 사용하는 방식
   - 프로세스는 논리적 주소를 사용하고 운영체제가 논리적 주소를 물리적 주소로 변환하여 메모리에 접근한다

2. 요구 페이징(Demand Paging)이란?
   - 프로세스 실행 중 필요한 페이지만 메모리에 로드하는 방식
   - 처음부터 모든 페이지를 메모리에 올리지 않고, 필요한 순간에 디스크에서 로드한다. page fault가 발생하면 해당 페이지를 메모리에 올린다.
   - 장점: 메모리 낭비를 줄이고 실행 속도를 최적화할 수 있음

3. 페이지 교체는 언제 발생하는가?
   - Page fault가 발생했을 때, 메모리에 빈 공간이 없을 경우 기존 페이지를 교체해야 할 때 발생함.

   a. 페이지 교체 알고리즘 종류
    - FIFO (First In First Out)
      - 가장 먼저 메모리에 들어온 페이지를 교체
    - LRU (Least Recently Used)
      - 가장 오래 사용되지 않는 페이지를 교체
    - LFU (Least Frequently Used)
      - 가장 적게 사용된 페이지를 교체
    - Clock Algorithm
      - Reference bit을 사용하여 최근에 사용되지 않는 페이지를 교체

4. Thrashing이란?
   - 프로세스가 과도한 page fault로 인하여 대부분의 시간을 페이지 교체에 소비하여 cpu 이용률이 감소하는 현상
   - 해결방법은?
     - 프로세스의 수를 줄임
     - working-set model
     - PFF (Page-Fault Frequency) Scheme

5. 메모리가 고갈되면 발생하는 현상은?
   - Thrashing 발생
   - 성능 저하
   - 데이터 손실 위험

### 입출력 시스템

1. RAID의 종류에는 무엇이 있는가?
   - RAID (Redundant Array of Independent Disk): 여러 디스크를 병렬로 연결하여 데이터의 성능 및 가용성을 높이는 기술
   - RAID 0 (striping)
     - RAID를 구성하는 모든 디스크에 데이터를 분할하여 저장
     - 용량이 증가하지만 안정성 문제 존재
   - RAID 1 (mirroring)
     - 모든 디스크에 데이터를 복제하여 저장
     - 안정성은 높으나 비용 문제 발생
   - RAID 4
     - block 단위로 striping을 하고, 패리티 디스크를 1개 사용함
     - 1개의 디스크 에러 시 복구 가능
   - RAID 5
     - block 단위로 striping을 하고, 패리티 디스크를 사용
     - 패리티 저장을 고정된 디스크에 하지 않으며, 매번 다른 디스크에 저장함
   - RAID 6
     - block 단위로 striping을 하고 패리티를 2개의 디스크에 저장하며, 패리티 저장은 고정된 디스크에 하지 않고, 매번 다른 디스크에 저장함
     - RAID 5에 비해 성능과 용량은 감소하나, 안정성이 증가함
   - Nested RAID (RAID 1+0, RAID 0+1)
     - RAID를 여러 개 중첩하여 사용하는 방식
     - RAID 1+0: RAID1를 RAID0으로 묶음

2. 버퍼링이란?
   - 데이터를 입력/출력 장치와 메모리 간 교환할 때, 속도 차이를 완화하기 위해 버퍼를 사용하는 기술