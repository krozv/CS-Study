## 운영체제란?
    운영체제 OS는 하드웨어 자원을 관리하고 응용 소프트웨어에 대한 서비스를 제공하는 소프트웨어입니다. 이는 사용자와 하드웨어 사이의 다리 역할을 합니다.

### 운영체제의 목적은?
    운영체제는 효율적인 리소스 관리, 프로세스 스케줄링 및 시스템 보안을 보장하고 시스템 상호 작용을 위한 사용자 친화적인 인터페이스를 제공합니다.

## 메모리 구조에 대해 설명해주세요.
    메모리는 코드 영역, 데이터 영역, 스택 영역, 힙 영역 등으로 구성되어 있습니다. 코드 영역의 실행 중인 프로세스의 코드를 저장하며, 데이터는 변수나 전역 변수등을 저장합니다. 스택 영역은 프로세스 실행 중에 함수 호출 및 로컬 변수를 위한 메모리 영역이며, 힙 영역은 동적으로 할당되는 메모리 영역입니다.

###  메모리의 힙 영역과 스택 영역의 차이점
    스택 영역은 메모리의 높은 주소에서 낮은 주소의 방향으로 할당되고 함수의 호출에 관계되는 지역 변수와 매개변수가 저장되는 영역입니다. 자동으로 관리됩니다. 힙 영역은  메모리의 낮은 주소에서 높은 주소로의 방향으로 할당되며 사용자가 직접 관리할 수 있는 메모리 영역입니다.

### 메모리의 힙 영역을 크게 잡을 때 생기는 문제점
    메모리의 힙 영역을 크게 잡을 경우 메모리 파편 문제가 생길 수도 있고, 사용자가 제대로 관리하지 않을 경우 메모리 부족 오류가 발생할 수 있습니다.

## 커널이란?
    커널은 OS의 핵심 소프트웨어로 하드웨어, 시스템 리소스를 관리하고, 프로세스 관리, 메모리 관리, 장치 제어와 같은 서비스를 제공합니다.

## 인터럽트란?
    인터럽트는 하드웨어나 소프트웨어에서 CPU로 보내는 신호로, 예외 상황이 발생해 처리가 필요할 때 CPU에게 알려 처리할 수 있도록 합니다. 인터럽트는 발생 요인에 따라 외부 인터럽트와 내부 인터럽트로 나눌 수 있습니다. 외부 인터럽트는 IO장치, Timer장치, 전원 등의 외부적인 요인으로 발생하는 인터럽트이며, 내부 인터럽트는 잘못된 명령이나 데이터를 사용할 때 발생합니다.

## 시스템 콜이란?
    시스템 콜은 권한이 필요한 작업, 예를 들어 파일 읽기 쓰기와 같이 낮은 수준의 작업을 수행하기 위해 프로그램이 커널에 요청하는 것입니다.

## Process와 Thread란?
    프로세스는 자체적인 메모리 공간을 가진 독립적인 실행 단위입니다. 그리고 스레드는 프로세스 안에서 다른 스레드와 메모리를 공유하는 프로세스의 하위 단위입니다. 한 개의 프로세스에는 최소 1개 이상의 스레드가 존재합니다.

### 차이점
    프로세스는 코드 영역, 데이터 영역, 스택 영역, 힙 영역을 고유하게 가집니다. 반면 스레드는 프로세스에서 최대한 공유가 가능한 부분을 공유하고 PCB의 Program Counter, Register, 스택 영역 등을 독자적으로 가져 메모리의 상당 부분을 세이브할 수 있는 이점을 가집니다.

## 크롬 브라우저에서 한 탭에 오류가 생기더라도, 다른 탭에 영향을 끼치지 않습니다. 그렇다면 각각의 크롬 탭은 프로세스일까요? 쓰레드일까요?
    크롬은 안정적인 사용자 경험을 위해 각각의 탭을 프로세스로 구성합니다.

## 쓰레드마다 독립적으로 할당하는 2가지는?
    스택 영역과 프로그램 카운터가 독립적으로 할당됩니다.

### 독립적으로 할당하는 이유는?
    충돌을 방지하고 CPU 자원을 독립적으로 점유할 수 있도록 보장하기 위함입니다.

## Multi-Process와 Multi-Thread란?
    멀티 프로세스는 여러 개의 독립적인 프로세스로 더 안전하지만 메모리 자원을 더 많이 잡아먹어 무겁습니다. 반면 멀티 스레드는 프로세스 내에 여러 개의 스레드가 존재하는 형태로 자원에 관해서는 효율적이지만 동기화 문제가 발생하기 쉽습니다.


## 멀티 프로세싱과 멀티 프로그래밍이란?
    멀티 프로세싱은 여러 CPU에서 여러 프로세스를 실행하는 것입니다. 멀티 프로그래밍은 Time Sharing을 통해 단일 CPU에서 여러 프로그램을 실행하는 것입니다.

## Context Switching이란?
    컨텍스트 스위칭은 CPU를 점유하고 있는 프로세스나 스레드를 다른 프로세스나 스레드로 전환하는 것입니다. 멀티 태스킹을 위한 핵심 기술이며 전환 시 컨텍스트를 저장하고 복구하는 작업으로 인해 오버헤드가 높습니다.

### 필요한 이유
    CPU 자원을 한 프로세스나 스레드가 독점하는 것을 방지하기 위함입니다.

## PCB란?
    프로세스 제어 블록은 컨텍스트 스위칭 중에 사용되는 상태나 프로세스 ID, 리소스 등의 프로세스 정보를 커널의 데이터 영역에 저장하는 자료 구조입니다. 커널은 이 정보를 통해 프로세스를 관리합니다.

## Thread-Safe란?
    동기화 매커니즘을 통해 Race Condition을 방지하여 다중 스레드 환경에서 올바르게 동작할 수 있도록 보장하는 것입니다.

## 멀티 쓰레드 환경에서 주의해야 할 점은?
    동기화를 보장해야 하며, 다수의 스레드가 공유 데이터에 동시에 접근하는 경우를 막기 위해 상호배제나 기타 동기화 기법을 통해 동시성 문제나 교착 상태가 발생하지 않도록 해야 합니다.

## Sync와 Async의 차이점은?
    동기는 작업이 순차적으로 진행되며 이전 작업이 완료될 때까지 다음 작업을 위한 실행이 보류됩니다. 반면 비동기는 시간이 많이 걸리는 작업은 요청만 해놓은 상태로 응답이 오기 전까지 다른 작업을 수행하므로써 응답성을 향상시키는 것입니다. 따라서 작업의 순서가 보장되지 않을 수 있습니다.

## Blocking과 Non-Blocking의 차이점은?
    블로킹은 다른 요청의 작업을 처리하기 위해 현재 작업을 막는 것입니다. 즉 현재 함수가 다른 함수를 호출했을 때 제어권을 다른 함수에게 넘겨주는 것이 블로킹, 호출했음에도 제어권을 넘겨주지 않고 그대로 가지고 다음 작업을 진행하는 것이 논블로킹입니다.

## 프로세스의 종류에는 무엇이 있는지 설명해주세요.
    프로세스의 종류에는 운영체제 수준의 시스템 프로세스, 사용자 프로그램을 실행하는 사용자 프로세스, 백그라운드 프로세스인 데몬 프로세스가 있습니다.

## 동시성과 병렬성의 차이는?
    동시성은 동시에 실행되는 것 같아 보이게 하는 것이고 병렬성은 실제로 동시에 여러 작업이 실행되는 것입니다. 동시성은 싱글 코어 컴퓨터에서 여러 개의 프로세스를 짧은 시간동안 번갈아 처리하므로써 사용자가 보기에 여러 작업을 동시에 처리하는 것처럼 보이게 합니다. 반면 병렬성은 여러 개의 코어를 사용해 실제로 작업을 동시에 처리하는 것입니다.

# CPU 스케줄링

## CPU Scheduling이란?
    CPU 스케줄링은 Ready Queue에 있는 프로세스 중에서 어떤 프로세스에게 CPU를 할당할지를 결정하는 과정입니다. CPU 사용률을 최적화하고 프로세스를 효율적으로 실행하기 위해 필수적입니다. 스케줄링은 CPU 스케줄러가 프로세스의 우선순위나 Burst time, 도착 시간 등을 기반으로 알고리즘을 적용해 수행합니다.

### CPU Scheduling의 종류
    CPU 스케줄링에는 기본적으로 먼저 오는 프로세스를 우선적으로 실행하는 First-Come, First-served 즉 FCFS가 있고, 실행 시간이 가장 짧은 프로세스를 우선적으로 실행하는 Shortest Job First, SJF, 고정된 시간 단위인 Time Quantum을 기반으로 프로세스를 번갈아 실행하는 Round Robin, 우선순위에 따라 프로세스를 실행하는 Priority Scheduling, 큐를 여러 수준으로 분리해 스케줄링하는 Multilevel Queue Scheduling이 있습니다.

## CPU의 성능 척도에 무엇이 있는가?
    CPU의 성능 척도는 CPU의 사용률, 단위 시간 당 완료된 프로세스의 수인 처리량, 그리고 시간이 있습니다. 일반적으로 시간은 짧을수록 좋고, 시간의 척도 또한 세 가지로 나뉘는데, 프로세스가 CPU를 점유하기 위해 대기하다가 처음으로 점유한 시간인 응답 시간, Ready Queue에 존재하는 동안 대기한 총 시간인 대기 시간, 대기 시간과 CPU를 사용한 시간의 총 합인 반환 시간이 있습니디.

## preemption과 non-preemption의 차이점은?
    선점 스케줄링은 실행 중인 프로세스로부터 CPU를 강제로 빼앗아 우선 순위가 높은 프로세스에 할당할 수 있는 스케줄링입니다. 반면, 비선점 스케줄링은 프로세스가 CPU 실행 시간을 완료할 때까지 중단할 수 없도록 합니다. 선점 스케줄링은 대기 중인 프로세스가 CPU를 점유할 수 있는 기회가 비교적 더 많으므로 응답성을 향상시키지만, 추가적인 오버헤드가 발생할 수 있습니다. 비선점 프로세스는 오버헤드가 적지만, 콘보이 효과와 같은 비효율적인 상황이 발생할 수 있습니다.

## Convoy Effect란?
    콘보이 효과는 비선점 스케줄링에서 실행시간이 긴 프로세스가 CPU를 사용해 더 짧은 실행 시간을 가진 프로세스들을 막아 지연이 발생하고 CPU 사용률을 낮추는 현상입니다. FCFS 알고리즘에서 특히 자주 발생할 수 있습니다. 먼저 들어온 프로세스가 17초, 나중에 들어온 프로세스들이 1~2초의 실행시간을 가지고 있다면 나중에 들어온 프로세스들이 먼저 실행된다면 더 효율적임에도 불구하고 먼저 들어온 프로세스 때문에 최소 17초 동안 기다려야 합니다.


# 병행 제어

## Race Condition과 Critical Section이란?
    Race Condition은 여러 프로세스나 스레드가 공유 자원에 동시에 접근하는 경우 고유 자원에 접근하는 순서에 따라 실행 결과가 달라지는 상황입니다. 즉, 접근하는 타이밍이나 순서에 따라 결괏값에 영향을 줄 수 있는 상태를 말합니다. Critical Section은 프로그램에서 공유 자원에 접근하는 코드의 일부를 말합니다.

## 운영체제에서 기아란?
    SJF처럼 우선순위가 더 높은 프로세스에게 지속적으로 접근 권한을 주는 스케줄링 방식에서 우선순위가 낮은 프로세스가 자원을 무한정 기다리는 현상입니다.

## 운영체제에서 에이징이란?
    에이징은 자원을 무한정 기다리는 프로세스의 우선순위를 점진적으로 높여 Starvation을 방지하는 기술입니다. 에이징을 통해 우선순위가 낮아 자원을 가져가지 못하던 프로세스도 실행될 수 있도록 합니다.

## Mutex와 Semaphore란?
    뮤텍스는 한 번에 하나의 프로세스나 스레드만 리소스에 액세스할 수 있도록 보장하는 잠금 변수입니다. Mutual Exclusion 즉 상호 배제의 약자입니다. 또 세마포어는 사용량을 추적하는 카운터 변수를 사용해 여러 개의 프로세스나 스레드가 제한된 수의 자원 인스턴스에 접근할 수 있도록 하는 매커니즘입니다.

## 스풀링이란?
    스풀링은 Simultaneous Peripheral Operations On-Line의 약자이며 버퍼링의 일종입니다. I/O장치와 같은 주변장치와 CPU 간의 처리 속도 차이에 의한 대기 속도를 줄이기 위해 데이터를 버퍼에 저장했다가 가용할 때 처리하는 것입니다.

## SpinLock이란?
    스핀락은 프로세스나 스레드가 자원의 가용 상태를 확인하기 위해 while문 등을 이용한 루프를 사용해 반복적으로 잠금 여부를 확인하는 것입니다. 짧은 대기 시간이라면 효율적이지만, 대기 시간이 길어진다면 확인을 위해 CPU를 계속해서 점유하고 사용하므로 자원이 낭비됩니다.

# 데드락

## DeadLock이란?
    데드락, 즉 교착 상태는 두 개 이상의 프로세스가 서로 가지고 있는 자원을 무한정 기다리면서 정체되는 상황입니다. 해결 방안이 없다면 더 이상 진행할 수 없으므로 시스템이 정지됩니다.

### a. 교착 상태의 4가지 필요 조건은?
    Mutual Exclusion 즉 상호 배제, Hold and Wait 점유 대기, No preemption 비선점, Circular wait 순환 대기입니다. 상호 배제는 한 시점에 하나의 자원에는 하나의 프로세스만 사용할 수 있는 것입니다. 점유 대기는 프로세스가 자원을 기다리는 동안 이미 획득한 자원을 계속해서 가지고 있는 것입니다. 그리고 비선점은 프로세스가 보유 중인 자원을 강제로 빼앗아 갈 수 없습니다. 마지막으로 순환 대기는 프로세스들 사이의 사이클이 형성되는 것입니다.


### b. 교착 상태 해결 방법은?
    교착 상태는 위에서 설명한 4가지 필요 조건 중에 하나만 깨뜨리면 해결됩니다. 이러한 방식을 Deadlock Prevention이라고 합니다. 강력한 방법이지만 비효율적이므로 막지는 않되, 자원 요청에 대해 Banker's algorithm과 같은 알고리즘을 사용해 안전한 상태를 유지하는 Deadlock Avoidance가 있습니다. 그리고 데드락은 비교적 가끔 발생하므로 데드락이 발생했는지 여부를 주기적으로 확인하고 프로세스를 종료하거나 롤백하는 방식으로 해결하는 Deadlock Detection and Recovery가 있습니다. 마지막으로 교착 상태를 무시해버리는 Deadlock Ignorance가 있습니다.

## Banker's algorithm이란?
    뱅커 알고리즘은 자원 요청을 동적으로 확인하는 데드락 방지 알고리즘입니다. 자원 요청 결과를 시뮬레이션하고 모든 프로세스가 데드락 없이 완료될 수 있는지 검증해 시스템이 안전한 상태를 유지할 수 있도록 보장합니다.

## '식사하는 철학자 문제'란?
    식사하는 철학자 문제는 식사를 하거나 생각하는 철학자들이 자신들의 좌우에 하나씩 놓인 젓가락을 공유하면서 발생하는 문제입니다. 철학자들이 모두 식사를 하기 위해서 왼쪽 젓가락을 집어든 경우 오른쪽 젓가락을 가질 수 없기 때문에 무한정 기다립니다. 이를 해결하는 방법으로는 젓가락을 집는 철학자의 수를 제한하거나, 짝수 철학자는 오른쪽 젓가락, 홀수 철학자는 왼쪽 젓가락을 먼저 집어들게 하여 젓가락의 우선순위를 부여해 주는 방법이 있습니다.

# 메모리 관리

## OS가 메모리 관리를 해야하는 이유는?
    운영체제는 제한된 메모리 자원을 여러 프로세스에 효율적으로 할당하고, 프로세스 간의 충돌을 방지하며, 성능을 최적화하기 위해 메모리를 관리합니다. 이를 통해 프로세스 간의 독립성을 보장하고 필요한 경우 메모리를 공유할 수 있도록 합니다.

### 메모리 관리를 위해 어떤 전략을 사용해야 하는지
    주요 전략으로는 페이징과 세그멘테이션, 그리고 가상 메모리가 있습니다. 이 전략들은 단편화를 줄여 메모리 활용을 극대화하고 물리 메모리가 부족한 경우에도 프로세스가 실행될 수 있도록 합니다.

!@#!@#!@#

## 메모리 할당 방식 중 연속(Contiguous) 방식과 불연속(Non-Contiguous) 방식이란?
    연속 할당은 프로세스에 연속된 메모리 블록을 할당하는 방식입니다. 단순하지만 외부 단편화를 가져올 수 있습니다. 그리고 비연속 할당은 프로세스를 여러 개의 비연속적인 블록으로 나누어 할당하는 방식으로, 페이징 또는 세그멘테이션을 통해 관리하며 단편화를 줄일 수 있습니다.

## 메모리 fit의 종류
    크게 최초 적합, 최적 적합, 최악 적합이 있습니다. 최초 적합은 프로세스에 필요한 메모리 크기 이상의 첫번째 블록을 할당하는 것입니다. 최적 적합은 프로세스에 필요한 메모리 크기와 가장 적합한 메모리 블록을 찾아 할당하는 방식으로 남는 공간을 최소화할 수 있습니다. 다만 빈 공간을 찾기 위해 모든 공간을 탐색해야 한다는 단점이 존재합니다. 마지막으로 최악 적합은 가장 큰 블록에 할당하는 것입니다. 외부 단편화가 가장 많이 발생할 수 있지만 큰 공간을 확보할 수 있습니다.

## Swapping이란?
    스와핑은 메모리에서 사용하지 않는 일부 프로세스를 주기억장치에서 보조기억장치로 내보내거나 필요한 프로세스를 다시 메모리로 불러오는 작업으로, 메모리 사용의 효율성을 높이기 위해 사용됩니다.

### Swapping 중에 발생하는 문제점
    잦은 스와핑은 디스크 작업량을 증가시키므로 시스템 속도를 저하시킬 수 있습니다. 또, 스와핑 작업이 과도하게 발생할 경우 CPU가 실제 작업보다 페이지 교체에 더 많은 시간을 소비하는 스래싱 현상이 발생할 수 있습니다.

## Paging과 Segmentation이란?
    페이징은 메모리를 고정된 크기의 페이지로 나누어 관리하는 기법으로 단편화를 줄일 수 있지만, 페이지 테이블 관리에 오버헤드가 발생합니다. 그리고 세그멘테이션은 메모리를 서로 다른 크기의 세그먼트로 나누어 관리하는 방식으로 내부 단편화 문제를 해소할 수 있지만, 외부 단편화가 생길 수 있습니다.

### 장단점
    페이징의 장점으로는 물리 메모리에 저장할 때 연속적으로 저장할 필요가 없고 물리 메모리의 비어있는 공간에 적절히 배치되므로 외부 단편화가 발생하지 않습니다. 하지만 단점으로 고정된 크기의 페이지를 사용하므로 내부 단편화가 발생할 수 있습니다. 세그멘테이션의 장점으로는 가변 크기의 세그먼트를 사용하므로 필요한 크기에 맞게 사용하면 내부 단편화 문제가 해소됩니다. 하지만 단점으로는 외부 단편화 문제가 해결되지는 않습니다.

## 내부단편화와 외부단편화란?
    내부 단편화는 메모리를 할당할 때 프로세스가 필요한 크기보다 더 큰 메모리가 할당되어서 프로세스에게 할당된 공간 안에서 메모리 공간이 낭비되는 상황입니다. 그리고 외부 단편화는 메모리가 할당되고 해제되는 작업이 반복되면서 할당된 메모리들 사이에 사용할 수 없는 작은 메모리 공간들이 생겨 낭비되는 것을 말합니다.

## 단편화를 해소하기 위한 방법은?
    단편화를 해소하기 위한 방법으로는 프로세스를 한쪽으로 모으는 압축 기법과 비연속 할당 방식을 사용하는 페이징이나 세그멘테이션 방식이 있습니다.

## DMA란?
    DMA는 하드웨어가 CPU의 개입 없이 직접 메모리에 접근할 수 있도록 하는 방식으로 CPU는 연산 작업에 집중할 수 있도록 부담을 줄이고 데이터 전송 속도를 향상시킬 수 있도록 합니다.

## 캐시 메모리를 사용하는 이유는?
    캐시 메모리는 CPU와 주기억장치 간의 속도 차이를 줄이기 위해 자주 사용하는 데이터를 저장해 데이터 접근 속도를 높이고 시스템 성능을 향상시킵니다.

# 가상 메모리
## 가상메모리란?
    가상 메모리는 물리적인 메모리 주소 공간보다 더 큰 주소 공간을 사용하기 위해 디스크의 일부를 메모리처럼 사용할 수 있도록 하는 기술입니다. 

## 요구 페이징(Demand Paging)이란?
    요구 페이징은 필요할 때만 페이지를 메모리에 적재하는 방식으로, 초기 로딩 시간을 줄일 수 있고 메모리 사용을 최적화할 수 있습니다.

## 페이지 교체는 언제 발생하는가?
    페이지 교체는 필요한 페이지가 메모리 상에 없는 Page Fault가 발생했을 때, 새로운 페이지를 적재할 메모리 공간이 없을 때 발생합니다.

### 페이지 교체 알고리즘 종류
    페이지 교체 알고리즘에는 FIFO, LRU, Optimal방식이 있습니다. FIFO 즉 First In First Out방식은 가장 오래된 페이지를 교체합니다. LRU 즉, Least Recently Used는 가장 오랫동안 사용되지 않았던 페이지를 교체합니다. 마지막으로 Optimal은 가장 이상적인 방식으로 미래에 가장 오랫동안 사용되지 않을 페이지를 교체하는 방식입니다. 하지만 실제로는 구현하기 어렵습니다.

## Thrashing이란?
    스래싱은 페이지 부재가 과도하게 발생해 CPU가 프로세스를 실행하는 본래의 목적보다 페이지 교체에 더 많은 시간이 소요되는  현상으로 시스템 성능이 크게 저하됩니다.

## 메모리가 고갈되면 발생하는 현상은?
    메모리가 부족하면 운영체제는 프로세스를 종료시키거나 스와핑을 증가시킵니다. 리눅스의 경우에는 메모리가 부족할 경우 OOM Killer 즉 Out of Memory Killer를 동작시켜 특정 프로세스를 종료시킵니다. 프로세스를 종료시키는 순위는 각 프로세스마다 점수를 계산해 가장 높은 점수의 프로세스부터 종료합니다.

# 입출력 시스템
## RAID의 종류에는 무엇이 있는가?
    레이드의 종류에는 RAID 0, RAID 1, RAID 4, RAID 5, RAID 6, 이 있습니다. RAID 0은 Striping이라고도 부르며 최소 두 개의 디스크에 데이터를 분할해 저장합니다. 전체디스크를 동시에 사용하기 때문에 성능과 용량은 N배로 증가하지만 한 개의 디스크라도 문제가 생기면 전체가 불량이 생길 수 있으므로 안정성은 1/N로 줄어듭니다. RAID 1은 Mirroring이라고도 부르며 최소 두 개의 디스크에 같은 데이터를 복제하는 방식입니다. 따라서 여러 개의 디스크를 RAID로 구성해도 전체 용량은 동일하지만 안정성이 높습니다. RAID 4는 최소 3개의 디스크를 사용해 하나를 패리티 디스크로 사용하고 나머지는 블록 단위로 Striping을 하는 방식입니다 성능과 용량이 N-1배 증가하며 패리티 디스크를 이용해 한 개의 디스크가 에러가 났을 때 복구가 가능합니다. RAID 5는 최소 3개의 디스크로 구성하며 블록 단위로 Striping을 하고 패리티는 매번 다른 디스크에 번갈아 저장합니다. RAID 4의 단점을 개선한 방식입니다. RAID 6은 최소 4개의 디스크로 구성하며 RAID 5에서 성능과 용량을 조금 포기하고 안정성을 더 높인 방식입니다. 패리티를 두 개의 디스크에 저장하며 매번 다른 디스크에 저장합니다. 용량과 성능은 N-2배 증가합니다.

## 버퍼링이란?
    버퍼링은 입출력 장치 간의 속도 차이를 완화하기 위해 데이터를 임시로 저장하는 버퍼를 사용하는 방식으로 데이터 전송 효율을 높일 수 있습니다.