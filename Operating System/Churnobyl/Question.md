## 운영체제란?
    운영체제 OS는 하드웨어 자원을 관리하고 응용 소프트웨어에 대한 서비스를 제공하는 소프트웨어입니다. 이는 사용자와 하드웨어 사이의 다리 역할을 합니다.

### 운영체제의 목적은?
    운영체제는 효율적인 리소스 관리, 프로세스 스케줄링 및 시스템 보안을 보장하고 시스템 상호 작용을 위한 사용자 친화적인 인터페이스를 제공합니다.

## 메모리 구조에 대해 설명해주세요.
    메모리는 코드 영역, 데이터 영역, 스택 영역, 힙 영역 등으로 구성되어 있습니다. 코드 영역의 실행 중인 프로세스의 코드를 저장하며, 데이터는 변수나 전역 변수등을 저장합니다. 스택 영역은 프로세스 실행 중에 함수 호출 및 로컬 변수를 위한 메모리 영역이며, 힙 영역은 동적으로 할당되는 메모리 영역입니다.

###  메모리의 힙 영역과 스택 영역의 차이점
    스택 영역은 메모리의 높은 주소에서 낮은 주소의 방향으로 할당되고 함수의 호출에 관계되는 지역 변수와 매개변수가 저장되는 영역입니다. 자동으로 관리됩니다. 힙 영역은  메모리의 낮은 주소에서 높은 주소로의 방향으로 할당되며 사용자가 직접 관리할 수 있는 메모리 영역입니다.

### 메모리의 힙 영역을 크게 잡을 때 생기는 문제점
    메모리의 힙 영역을 크게 잡을 경우 메모리 파편 문제가 생길 수도 있고, 사용자가 제대로 관리하지 않을 경우 메모리 부족 오류가 발생할 수 있습니다.

## 커널이란?
    커널은 OS의 핵심 소프트웨어로 하드웨어, 시스템 리소스를 관리하고, 프로세스 관리, 메모리 관리, 장치 제어와 같은 서비스를 제공합니다.

## 인터럽트란?
    인터럽트는 하드웨어나 소프트웨어에서 CPU로 보내는 신호로, 예외 상황이 발생해 처리가 필요할 때 CPU에게 알려 처리할 수 있도록 합니다. 인터럽트는 발생 요인에 따라 외부 인터럽트와 내부 인터럽트로 나눌 수 있습니다. 외부 인터럽트는 IO장치, Timer장치, 전원 등의 외부적인 요인으로 발생하는 인터럽트이며, 내부 인터럽트는 잘못된 명령이나 데이터를 사용할 때 발생합니다.

## 시스템 콜이란?
    시스템 콜은 권한이 필요한 작업, 예를 들어 파일 읽기 쓰기와 같이 낮은 수준의 작업을 수행하기 위해 프로그램이 커널에 요청하는 것입니다.

## Process와 Thread란?
    프로세스는 자체적인 메모리 공간을 가진 독립적인 실행 단위입니다. 그리고 스레드는 프로세스 안에서 다른 스레드와 메모리를 공유하는 프로세스의 하위 단위입니다. 한 개의 프로세스에는 최소 1개 이상의 스레드가 존재합니다.

### 차이점
    프로세스는 코드 영역, 데이터 영역, 스택 영역, 힙 영역을 고유하게 가집니다. 반면 스레드는 프로세스에서 최대한 공유가 가능한 부분을 공유하고 PCB의 Program Counter, Register, 스택 영역 등을 독자적으로 가져 메모리의 상당 부분을 세이브할 수 있는 이점을 가집니다.

## 크롬 브라우저에서 한 탭에 오류가 생기더라도, 다른 탭에 영향을 끼치지 않습니다. 그렇다면 각각의 크롬 탭은 프로세스일까요? 쓰레드일까요?
    크롬은 안정적인 사용자 경험을 위해 각각의 탭을 프로세스로 구성합니다.

## 쓰레드마다 독립적으로 할당하는 2가지는?
    스택 영역과 프로그램 카운터가 독립적으로 할당됩니다.

### 독립적으로 할당하는 이유는?
    충돌을 방지하고 CPU 자원을 독립적으로 점유할 수 있도록 보장하기 위함입니다.

## Multi-Process와 Multi-Thread란?
    멀티 프로세스는 여러 개의 독립적인 프로세스로 더 안전하지만 메모리 자원을 더 많이 잡아먹어 무겁습니다. 반면 멀티 스레드는 프로세스 내에 여러 개의 스레드가 존재하는 형태로 자원에 관해서는 효율적이지만 동기화 문제가 발생하기 쉽습니다.


## 멀티 프로세싱과 멀티 프로그래밍이란?
    멀티 프로세싱은 여러 CPU에서 여러 프로세스를 실행하는 것입니다. 멀티 프로그래밍은 Time Sharing을 통해 단일 CPU에서 여러 프로그램을 실행하는 것입니다.

## Context Switching이란?
    컨텍스트 스위칭은 CPU를 점유하고 있는 프로세스나 스레드를 다른 프로세스나 스레드로 전환하는 것입니다. 멀티 태스킹을 위한 핵심 기술이며 전환 시 컨텍스트를 저장하고 복구하는 작업으로 인해 오버헤드가 높습니다.

### 필요한 이유
    CPU 자원을 한 프로세스나 스레드가 독점하는 것을 방지하기 위함입니다.

## PCB란?
    프로세스 제어 블록은 컨텍스트 스위칭 중에 사용되는 상태나 프로세스 ID, 리소스 등의 프로세스 정보를 커널의 데이터 영역에 저장하는 자료 구조입니다. 커널은 이 정보를 통해 프로세스를 관리합니다.

## Thread-Safe란?
    동기화 매커니즘을 통해 Race Condition을 방지하여 다중 스레드 환경에서 올바르게 동작할 수 있도록 보장하는 것입니다.

## 멀티 쓰레드 환경에서 주의해야 할 점은?
    동기화를 보장해야 하며, 다수의 스레드가 공유 데이터에 동시에 접근하는 경우를 막기 위해 상호배제나 기타 동기화 기법을 통해 동시성 문제나 교착 상태가 발생하지 않도록 해야 합니다.

## Sync와 Async의 차이점은?
    동기는 작업이 순차적으로 진행되며 이전 작업이 완료될 때까지 다음 작업을 위한 실행이 보류됩니다. 반면 비동기는 시간이 많이 걸리는 작업은 요청만 해놓은 상태로 응답이 오기 전까지 다른 작업을 수행하므로써 응답성을 향상시키는 것입니다. 따라서 작업의 순서가 보장되지 않을 수 있습니다.

## Blocking과 Non-Blocking의 차이점은?
    블로킹은 다른 요청의 작업을 처리하기 위해 현재 작업을 막는 것입니다. 즉 현재 함수가 다른 함수를 호출했을 때 제어권을 다른 함수에게 넘겨주는 것이 블로킹, 호출했음에도 제어권을 넘겨주지 않고 그대로 가지고 다음 작업을 진행하는 것이 논블로킹입니다.

## 프로세스의 종류에는 무엇이 있는지 설명해주세요.
    프로세스의 종류에는 운영체제 수준의 시스템 프로세스, 사용자 프로그램을 실행하는 사용자 프로세스, 백그라운드 프로세스인 데몬 프로세스가 있습니다.

## 동시성과 병렬성의 차이는?
    동시성은 동시에 실행되는 것 같아 보이게 하는 것이고 병렬성은 실제로 동시에 여러 작업이 실행되는 것입니다. 동시성은 싱글 코어 컴퓨터에서 여러 개의 프로세스를 짧은 시간동안 번갈아 처리하므로써 사용자가 보기에 여러 작업을 동시에 처리하는 것처럼 보이게 합니다. 반면 병렬성은 여러 개의 코어를 사용해 실제로 작업을 동시에 처리하는 것입니다.

# CPU 스케줄링

## CPU Scheduling이란?
    CPU 스케줄링은 Ready Queue에 있는 프로세스 중에서 어떤 프로세스에게 CPU를 할당할지를 결정하는 과정입니다. CPU 사용률을 최적화하고 프로세스를 효율적으로 실행하기 위해 필수적입니다. 스케줄링은 CPU 스케줄러가 프로세스의 우선순위나 Burst time, 도착 시간 등을 기반으로 알고리즘을 적용해 수행합니다.

### CPU Scheduling의 종류
    CPU 스케줄링에는 기본적으로 먼저 오는 프로세스를 우선적으로 실행하는 First-Come, First-served 즉 FCFS가 있고, 실행 시간이 가장 짧은 프로세스를 우선적으로 실행하는 Shortest Job First, SJF, 고정된 시간 단위인 Time Quantum을 기반으로 프로세스를 번갈아 실행하는 Round Robin, 우선순위에 따라 프로세스를 실행하는 Priority Scheduling, 큐를 여러 수준으로 분리해 스케줄링하는 Multilevel Queue Scheduling이 있습니다.

## CPU의 성능 척도에 무엇이 있는가?
    CPU의 성능 척도는 CPU의 사용률, 단위 시간 당 완료된 프로세스의 수인 처리량, 그리고 시간이 있습니다. 일반적으로 시간은 짧을수록 좋고, 시간의 척도 또한 세 가지로 나뉘는데, 프로세스가 CPU를 점유하기 위해 대기하다가 처음으로 점유한 시간인 응답 시간, Ready Queue에 존재하는 동안 대기한 총 시간인 대기 시간, 대기 시간과 CPU를 사용한 시간의 총 합인 반환 시간이 있습니디.

## preemption과 non-preemption의 차이점은?
    선점 스케줄링은 실행 중인 프로세스로부터 CPU를 강제로 빼앗아 우선 순위가 높은 프로세스에 할당할 수 있는 스케줄링입니다. 반면, 비선점 스케줄링은 프로세스가 CPU 실행 시간을 완료할 때까지 중단할 수 없도록 합니다. 선점 스케줄링은 대기 중인 프로세스가 CPU를 점유할 수 있는 기회가 비교적 더 많으므로 응답성을 향상시키지만, 추가적인 오버헤드가 발생할 수 있습니다. 비선점 프로세스는 오버헤드가 적지만, 콘보이 효과와 같은 비효율적인 상황이 발생할 수 있습니다.

## Convoy Effect란?
    콘보이 효과는 비선점 스케줄링에서 실행시간이 긴 프로세스가 CPU를 사용해 더 짧은 실행 시간을 가진 프로세스들을 막아 지연이 발생하고 CPU 사용률을 낮추는 현상입니다. FCFS 알고리즘에서 특히 자주 발생할 수 있습니다. 먼저 들어온 프로세스가 17초, 나중에 들어온 프로세스들이 1~2초의 실행시간을 가지고 있다면 나중에 들어온 프로세스들이 먼저 실행된다면 더 효율적임에도 불구하고 먼저 들어온 프로세스 때문에 최소 17초 동안 기다려야 합니다.