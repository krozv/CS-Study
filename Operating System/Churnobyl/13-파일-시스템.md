# 파일 시스템

slug: file-system
tags: OS
version: 1

# 파일과 파일 시스템

## 파일 (File)

파일은 컴퓨터에서 데이터를 저장하기 위한 논리적인 단위입니다. 텍스트, 이미지, 비디오, 오디오, 프로그램 실행 파일 등 다양한 데이터 형식이 파일로 저장됩니다. 운영체제는 다양한 저장장치를 File이라는 논리적 단위로 볼 수 있게 해줍니다.

## 메타데이터 (Metadata; File Attribute)

메타데이터는 파일 자체의 내용이 아니라 파일을 관리하기 위한 각종 정보들의 집합입니다. 파일 이름, 유형, 저장된 위치, 파일 사이즈와 같은 정보 뿐만 아니라 읽기/쓰기/실행에 대한 접근 권한과 생성 시간/변경  시간/사용 시간, 소유자 등의 정보까지 기록되어 있습니다.

## 파일 시스템

파일 시스템은 운영체제에서 파일을 관리하는 소프트웨어 구현부로 하드 디스크, SSD와 같은 저장 장치에 데이터를 효율적으로 저장, 검색, 관리하기 위한 체계입니다. 파일과 디렉토리를 체계적으로 관리해 사용자가 데이터를 쉽게 접근하고 저장할 수 있게 합니다.

### 파일 시스템의 주요 역할

- 저장 및 검색 : 파일을 저장하고 필요할 때 검색할 수 있도록 함
- 디렉토리 구조 관리 : 파일과 디렉토리를 계층 구조로 관리
- 데이터 무결성 보장 : 저장된 데이터가 손상되지 않도록 보호
- 액세스 제어 : 사용자별로 파일에 대한 권한을 설정
- 공간 관리 : 디스크 공간을 효율적으로 사용

### 파일 시스템의 구성 요소

1. 파일 디스크립터 (File Descriptor)
    1. 운영 체제가 파일을 추적하는 데 사용하는 메타데이터
    2. 파일 이름, 크기 위치, 권한 등의 정보를 포함
2. 디렉토리 (Directory)
    1. 파일과 다른 디렉토리를 포함하는 컨테이너
    2. 계층적 구조(Hierarchical Structure)로 구성
3. 인덱스 (Indexes)
    1. 파일이 저장된 위치를 추적하기 위해 사용되는 데이터 구조
    2. FAT, inode, B-tree 등 다양한 방식을 사용
4. 저장 장치
    1. 하드 디스크, SSD, USB 등 물리적인 데이터 저장 매체

## 파일 시스템의 유형

### 디스크 기반 파일 시스템

- NTFS (New Technology File System)
    - Windows에서 주로 사용하는 파일 시스템
    - 보안 기능, 암호화, 대용량 파일 지원, 저널링 제공
- FAT32 (File Allocation Table)
    - 이전 파일 시스템으로 간단한 구조와 광범위한 호환성 제공
    - 4GB를 초과하는 대용량 파일에 대한 지원을 하지 않음
- ext4 (Fourth Extended File System)
    - Linux에서 널리 사용되는 파일 시스템
    - 대용량 파일 지원, 저널링, 빠른 성능 제공

### 저널링 (Journaling)

저널링은 파일 시스템의 무결성을 보장하기 위한 기술로 파일 시스템이 데이터를 쓰거나 수정하는 작업을 로그(저널)에 기록하는 기능입니다. 시스템이 갑작스럽게 중단되거나 장애가 발생하더라도 저널링을 통해 파일 시스템의 상태를 복구할 수 있습니다.

### 네트워크 파일 시스템

- NFS (Network File System)
    - 네트워크를 통해 원격 파일 시스템에 접근
    - Unix/Linux 환경에서 주로 사용

### 분산 파일 시스템

- HDFS (Hadoop Distributed File System)
    - 빅데이터 처리를 위한 분산 파일 시스템
    - 데이터 복제를 통해 신뢰성과 확장성을 제공

## 파티션(Partition)

파티션은 연속된 저장 공간을 하나 이상의 연속되고 독립적인 영역으로 나누어 사용할 수 있도록 정의한 규약입니다. 하나의 물리적 디스크 안에 여러 파티션을 두는 게 일반적이지만, 여러 물리적 디스크를 하나의 파티션으로 구성하기도 합니다.

# 파일 접근 방법 (Access Methods)

운영 체제는 파일의 데이터를 효율적으로 읽고 쓸 수 있도록 다양한 파일 접근 방법을 제공합니다. 각 접근 방법은 파일을 처리하는 방식, 사용 사례, 성능 요구 사항 등에 따라 다릅니다. 

### 1. 순차 접근(Sequential Access)

![https://blog.kakaocdn.net/dn/n9ifN/btrgvqo8ivJ/5nWEa4e9rKUK9MBtPRqyCK/img.png](https://blog.kakaocdn.net/dn/n9ifN/btrgvqo8ivJ/5nWEa4e9rKUK9MBtPRqyCK/img.png)

파일의 데이터를 순서대로 처리하는 방법입니다. 현재 파일 위치에서 데이터를 읽거나 쓰면 파일 포인터(File Pointer)가 자동으로 다음 위치로 이동합니다. 과거의 카세트 테이프와 비슷한 방식으로 특정 위치로 돌아가려면 데이터를 거꾸로 읽어야 합니다.

파일을 처음부터 끝까지 순서대로 처리하므로 구현이 쉽고 추가적인 인덱스 관리가 필요없기 때문에 사용기 쉬운 장점이 있지만, 원하는 데이터에 빠르게 접근할 수 없고 큰 파일 처리에 비효율적인 단점이 있습니다.

데이터가 순차적으로 기록되는 로그 파일이나 비디오, 오디오 데이터의 스트리밍 등에 사용될 수 있습니다.

### 2. 랜덤 접근(Random Access)

파일의 데이터를 임의의 위치에서 읽거나 쓸 수 있는 방식입니다. LP 레코드판과 비슷한 방식으로 특정 트랙으로 바로 이동할 수 있습니다.

임의의 데이터에 빠르게 접근할 수 있고 순차적인 읽기와 임의 접근 모두 지원하는 장점이 있지만, 파일 포인터를 직접 관리해야 하므로 순차 접근에 비해 구현이 복잡하며 임의 접근을 지원하기 위한 추가 메모리가 필요하다는 단점이 있습니다.

데이터베이스 파일이나 특정 프레임이나 시간대 데이터를 즉시 접근해야 하는 멀티미디어 파일에 사용할 수 있습니다.

### 3. 색인 접근(Index Access)

![https://blog.kakaocdn.net/dn/ucSgw/btrgqyn2f1Z/rTRsabKKW7LPca4o5307L0/img.png](https://blog.kakaocdn.net/dn/ucSgw/btrgqyn2f1Z/rTRsabKKW7LPca4o5307L0/img.png)

색인 접근은 파일 데이터의 위치를 나타내는 인덱스를 활용해 원하는 데이터를 빠르게 찾는 방식입니다. 도서관의 색인과 유사한 개념으로 먼저 색인을 보고 원하는 항목을 찾아 이동합니다.

인덱스는 파일의 각 데이터 블록이나 레코드에 대한 포인터를 포함하고 있고, 데이터의 시작 위치나 특정 항목의 주소를 제공합니다. 그리고 인덱스에서 얻은 정보를 기반으로 데이터를 읽거나 쓸 수 있습니다.

인덱스를 활용해 데이터를 효율적으로 탐색할 수 있으므로 빠른 데이터 접근이 가능하고 큰 파일에서 장점을 가지지만 역시 추가적인 저장 공간이 필요하며 데이터가 수정되었을 때 인덱스도 함께 수정해야 하므로 인덱스 관리가 복잡할 수 있습니다.

대규모 데이터베이스 시스템이나 검색 엔진 등에서 사용할 수 있습니다.

# 디렉터리

디렉터리는 파일에 대한 메타데이터를 저장하는 특별한 파일입니다. 디렉터리는 파일 이름과 속성을 저장하며 파일과 디렉터리를 효율적으로 관리하기 위해 여러 기능을 제공합니다. 주요 기능으로는 파일 검색(Search), 파일 생성(Create), 파일 삭제(Delete), 디렉터리 목록(List), 파일 이름 변경(Rename), 파일 시스템 순회(Traverse) 등이 있습니다.

## 디렉터리 구조

디렉터리는 효율적인 탐색, 사용자의 편의성, 파일 분류를 위해 논리적인 구조가 필요합니다. 논리적인 구조를 정의하는 것은 여러 방법이 있습니다.

### 1단계 디렉터리 (Single-Level Directory)

- 모든 파일이 하나의 디렉터리 안에 저장
- 모든 파일 이름은 고유해야 하며 사용자 간 이름 충돌이 발생할 수 있음
- 파일 검색 및 관리가 간단하고 구현이 쉬운 장점
- 여러 사용자 환경에서 동일한 파일 이름 사용 불가능하고 파일 수 많아지면 탐색 속도 느려지는 단점
- 초기 파일 시스템에서 사용

### 2단계 디렉터리 (Two-Level Directory)

- 사용자마다 별도의 디렉터리를 제공
- MFD (Master File Directory) : 사용자 이름과 계정을 기준으로 UFD를 관리
- UFD (User File Directory) : 각 사용자의 개별 파일 디렉토리
- 사용자 간 파일 이름 충돌이 발생하지 않고 각 사용자 디렉토리에서 효율적으로 파일 검색이 가능한 장점
- 그룹화 기능이 부족하고 다른 사용자의 파일에 접근하기 어렵다는 단점
- 개인화된 사용자 파일 디렉터리가 필요한 시스템에서 사용

### 트리 구조 디렉터리 (Tree-Structured Directory)

- 디렉터리는 트리 구조를 가지며 루트 디렉터리 아래에 하위 디렉터리와 파일을 계층적으로 배치
- 파일은 절대 경로 또는 상대 경로로 참조
- 사용자 정의 하위 디렉터리를 생성할 수 있고 파일 및 디렉터리의 논리적 그룹화가 가능하며 효율적인 탐색 및 관리가 가능한 장점
- 디렉터리가 깊어지면 경로 탐색이 복잡해질 수 있는 단점
- 현재 운영체제(Windows, Unix/Linux)의 파일 시스템에서 사용

### 비순환 그래프 디렉터리 (Acyclic-Graph Directory)

- 트리 구조에서 확장된 형태로 파일이나 디렉터리가 여러 디렉터리에서 참조될 수 있음
- 참조 횟수를 사용해 파일의 사용 상태를 추적
- 파일과 디렉터리를 공유할 수 있어 공간 효율성이 향상하고 유연한 파일 접근이 가능한 장점
- 참조가 남아있는 파일을 삭제하면 문제가 발생할 수 있어 참조 횟수가 0이 된 경우에만 파일이 삭제 가능한 단점
- NFS 등에서 파일 공유에 사용

### 일반 그래프 디렉터리 (General Graph Directory)

- 순환을 허용한 디렉터리 구조
- 디렉터리와 파일 간에 링크를 생성해 더 유연한 구조를 제공
- 파일과 디렉터리의 복잡한 참조 관계를 지원하며 파일 시스템 설계에 유연성을 제공하는 장점
- 순환 참조가 발생한 경우 탐색이 끝나지 않을 수 있는 단점
- 순환 참조를 방지하기 위해 하위 디렉터리로의 링크를 허용하지 않고, GC나 마킹을 사용해 유효하지 않은 링크를 제거 할 수 있음
- 파일 시스템에서 고급 파일 링크가 필요한 환경에 사용

# 디스크에서 파일 데이터의 할당

운영 체제는 디스크에 데이터를 효율적으로 저장하고 관리하기 위해 다양한 파일 할당 기법을 사용합니다. 이 기법들은 디스크 블록에 파일 데이터를 배치하는 방법과 관련이 있으며, 각각의 기법은 성능, 공간 효율성, 접근 속도 등에 따라 장단점이 있습니다.

### Contiguous Allocation

![https://blog.kakaocdn.net/dn/AtEx7/btrgCG6nwMN/xisipfbEKJmU3oqruPNkVk/img.png](https://blog.kakaocdn.net/dn/AtEx7/btrgCG6nwMN/xisipfbEKJmU3oqruPNkVk/img.png)

연속 할당은 파일 데이터를 디스크의 연속된 블록에 저장하는 방식입니다. 파일에 대한 메타데이터에는 파일의 시작 위치와 길이 정보가 저장되며, 이 정보를 이용해 데이터를 효율적으로 읽거나 쓸 수 있습니다. 

### 2. Linked Allocation

![https://blog.kakaocdn.net/dn/AvQSs/btrgBmt1eAM/22IaMokJ25BqTFM0pwFNuK/img.png](https://blog.kakaocdn.net/dn/AvQSs/btrgBmt1eAM/22IaMokJ25BqTFM0pwFNuK/img.png)

연결 할당은 파일 데이터를 연속되지 않은 블록에 저장하며, 각 블록이 다음 블록을 가리키는 포인터를 포함하는 방식입니다. 디렉터리에는 파일의 시작 블록과 끝 블록만 저장됩니다.

# 3. Indexed Allocation

![https://blog.kakaocdn.net/dn/kWG75/btrgALVnO6k/bj8UJ2IjR2MJnMYEipXxck/img.png](https://blog.kakaocdn.net/dn/kWG75/btrgALVnO6k/bj8UJ2IjR2MJnMYEipXxck/img.png)

인덱스 할당은 파일의 모든 블록 주소를 인덱스 블록에 저장하는 방식입니다. 디렉터리에는 파일의 인덱스 블록 위치만 저장되며, 이 정보를 통해 파일 데이터를 추적합니다.