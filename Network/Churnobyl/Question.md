# 네트워크 계층
## 네트워크 계층의 주요 역할은 무엇인가요?
    네트워크 계층의 주요 역할은 데이터 패킷이 이동할 최적의 경로를 결정해 네트워크를 통한 데이터 전송이 가능하도록 하는 것입니다. 이는 네트워크의 최대 전송 단위인 MTU에 맞게 IP 주소 지정과 IP단편화를 처리합니다. 여러 라우터를 거치더라도 패킷이 목적지에 도달할 수 있도록 보장합니다.
## IP는 무엇인가요?
    IP는 인터넷 프로토콜의 약자로 네트워크를 통한 데이터 패킷의 형식과 전송에 관한 규약입니다. IP주소를 통해 패킷의 주소를 지정하고 수신지 주소로 라우팅하는 일을 담당합니다. IP는 OSI 모델에서 네트워크 계층에 속합니다.
## IP 주소와 MAC 주소의 차이는 무엇인가요?
    IP주소는 네트워크에서 대상을 식별하기 위해 부여한 논리적인 주소이며 변경이 가능합니다. 그리고 MAC주소는 제조업체가 NIC에 내장한 물리적인 주소이며 장치마다 고유한 주소를 가지고 있습니다. IP주소는 라우팅을 위해 사용되고, MAC주소는 동일한 네트워크 내에서 프레임을 전달하기 위해 사용됩니다.
## IPv4와 IPv6의 차이점은 무엇인가요?
    IPv4는 약 43억 개의 주소를 처리할 수 있는 32비트 주소 지정 시스템이며, IPv6는 128비트 주소 지정 시스템이므로 아주 큰 주소를 처리할 수 있습니다. 추가적으로 IPv6는 효율적인 라우팅 방식, IPsec과 같은 내장 보안 기능, 그리고 IPv4에 비해 단순화된 패킷 헤더를 지원합니다.
## 서브넷 마스크란 무엇이며, 왜 사용하나요?
    서브넷 마스크는 IP 주소를 네트워크와 호스트 부분으로 분리하는 방식입니다. 이는 더 큰 네트워크를 더 작은 하위 네트워크로 나누는데 사용되며, 서브넷 내에서 트래픽을 격리해 라우팅 효율성과 네트워크 보안을 향상시킬 수 있습니다.
## 라우터와 스위치의 차이는 무엇인가요?
    라우터는 서로 다른 네트워크를 연결하고 IP 주소를 사용해 네트워크 간의 데이터 패킷을 전달하는 장치입니다. 그리고 스위치는 단일 네트워크 내에서 작동해 MAC주소를 기반으로 장치를 연결하고 데이터를 전달합니다. 라우터는 네트워크 계층, 스위치는 데이터 링크 계층에서 작동합니다.
## 라우팅 프로토콜(예: OSPF, BGP)의 종류와 차이점을 설명해주세요.
    OSPF, Open Shortest Path First는 단일 조직의 네트워크 내에서 사용되는 내부 게이트웨이 프로토콜(IGP)입니다. 링크 상태 라우팅을 사용하며 다익스트라 알고리즘을 사용해 최단 경로를 계산합니다. BGP, Border Gateway Protocol은 서로 다른 조직이나 ISP 간에 트래픽을 라우팅하는 데 사용되는 외부 게이트웨이 프로토콜(EGP)입니다. 경로 벡터 라우팅을 사용하며 최단 경로보다 정책의 우선순위를 지정하는 방식을 사용합니다.
## CIDR(Classless Inter-Domain Routing)이란 무엇인가요?
    사이더 혹은 시더라고 부르는 CIDR는 기존의 클래스 기반 주소 지정을 대체하는 IP 주소 할당 및 라우팅 방식입니다. 이를 통해 IP주소를 가변 크기의 서브넷으로 유연하게 분할할 수 있고 한정된 주소 공간을 효율적으로 사용하며 라우팅 효율성 또한 향상시킬 수 있습니다.
## NAT(Network Address Translation)는 무엇이며, 어떤 문제를 해결하나요?
    NAT는 개인 네트워크 안에서 여러 개의 장치가 외부 네트워크에 접근할 때 단일 공용 IP 주소를 공유할 수 있습니다. 이를 통해 IPv4의 주소 고갈 문제를 해결하고 외부 네트워크로부터 내부 IP주소를 숨겨 보안을 향상시킬 수 있습니다.
## 공인 IP와 사설 IP의 차이에 대해 설명해주세요.
    공인 IP는 네트워크 전역적으로 고유하며 인터넷에서 장치를 식별하기 위해 사용됩니다. 반면 사설 IP는 로컬 네트워크 내에서 사용되며 인터넷에서 라우팅할 수 없습니다.

# 전송 계층
## 전송 계층의 역할과 주요 프로토콜은 무엇인가요?
    전송 계층은 네트워크 계층과 응용 계층 사이에 위치해 IP의 한계를 극복하고 신뢰할 수 있는 통신과 연결형 통신을 가능하게 합니다. 주요 프로토콜로는 안정적인 연결을 지향하는 TCP통신과 빠르고 비연결성 통신을 지향하는 UDP가 있습니다.
## 포트가 무엇이고, 소켓이 무엇인지 설명해주세요.
    포트는 동일한 장치 내에서 서로 다른 서비스를 구분하기 위해 사용되는 숫자입니다. HTTP를 위한 80포트나 HTTPS를 위한 443포트 등이 대표적입니다. 소켓은 IP주소와 포트 번호의 조합으로 장치와 특정한 서비스 간의 통신을 가능하게 합니다.
## TCP와 UDP의 차이점은 무엇인가요?
    TCP는 연결 지향적입니다. 승인, 재전송, 흐름 제어 등을 통해 안정적으로 데이터 전달을 할 수 있습니다. 반면 UDP는 속도를 중시하기 위해 연결없이 데이터를 보내기만 합니다. 비디오 스트리밍처럼 시간이 중요하고 패킷이 일부 손실되는 것이 상관없을 때 많이 사용합니다.
## TCP의 문제점은?
    TCP의 문제점으로는 재전송이나 혼잡 제어와 같이 안정성을 높이기 위한 매커니즘 때문에 대기 시간과 오버헤드가 발생할 수 있습니다. 그래서 실시간 애플리케이션에서는 적합하지 않습니다.
## TCP의 3way handshake, 4way handshake에 대해서 설명해주세요
    3 way handshake는 연결을 수립하기 위한 과정입니다. 클라이언트가 먼저 SYN을 보내고 서버는 SYN-ACK로 응답합니다. 그리고 마지막으로 클라이언트가 ACK로 다시 응답하면 연결이 수립됩니다. 4 way handshake는 연결을 종료하기 위한 과정입니다. 서버나 클라이언트 중에서 연결을 종료하고자 하는 당사자가 FIN을 보내면 다른 당사자가 ACK로 승인하고 다시 FIN를 보냅니다. 최종적으로 다시 당사자가 ACK를 보내면 연결이 종료됩니다.
## UDP에 Checksum 필드가 있는 이유는 무엇일까요?
    UCP의 체크섬 필드가 있는 이유는 전송된 데이터그램에서 오류를 감지해 데이터 무결성을 보장하기 위함입니다. 체크섬이 일치하지 않으면 패킷이 삭제됩니다.
## 전송 계층과 데이터링크 계층 모두 신뢰성 관련 기능을 제공하는데, 어떤 차이가 있나요?
    전송 계층에서는 장치 간에 종단 간 신뢰성을 보장하는 반면에, 데이터 링크 계층에서는 단일 네트워크내에서 신뢰성을 보장합니다.
## 전송 계층이 데이터 분실을 확인하는 방법에 대해 설명해주세요.
    전송 계층에서는 데이터 분실을 확인하기 위해서 시퀀스 번호와 승인을 사용합니다. 만약 제한 시간 내에 승인이 수신되지 않으면 데이터가 다시 재전송됩니다.
## 전송 계층이 제공하는 신뢰성 관련 기능 중, 흐름제어에 대해 설명해주세요.
    흐름 제어는 주로 슬라이딩 윈도우 알고리즘을 사용해 구현되는데, 데이터 전송 속도를 조절해 수신 장치에 부담을 주지 않도록 합니다.
## 전송 계층이 제공하는 신뢰성 관련 기능 중, 오류제어(재전송 프로토콜) 대해 설명해주세요.
    오류 제어는 승인 및 시간 초과를 사용해 손실되거나 손상된 패킷을 감지하고 재전송해 안정적으로 데이터를 전달받을 수 있도록 보장합니다.
## 전송 계층이 제공하는 신뢰성 관련 기능 중, 혼잡제어에 대해 설명해주세요.
    혼잡 제어는 네트워크의 상태에 따라 데이터 전송 속도를 조절해 혼잡을 방지하거나 완화시킵니다. TCP는 느린 시작 및 혼잡 회피와 같은 방법을 사용합니다.
## Connection Timeout과 Read Timeout의 차이에 대해 설명해주세요.
    커넥션 타임아웃은 연결을 수립하는 데 걸리는 최대 시간을 지정하고, 리드 타임아웃은 연결이 수립된 후 데이터를 기다리는 최대 시간을 지정합니다.
## NAT 환경에서 포트 포워딩이란 무엇인가요?
    포트 포워딩은 NAT 라우터의 외부 포트를 내부 장치의 IP 주소 및 포트와 매핑해 개인 네트워크 안에서 특정 서비스에 대한 외부 액세스를 허용하는 것입니다.
## TLS(Transport Layer Security)는 전송 계층에서 어떻게 동작하나요?
    TLS는 전송 계층을 통해 전송되는 데이터를 암호화해 기밀성, 무결성 및 인증을 제공합니다. 대칭 암호화, 비대칭 암호화, 그리고 디지털 인증서의 조합을 사용합니다.

# DNS, HTTP, 쿠키, 캐시
## DNS, DNS Lookup 과정에 대해 설명해주세요
    Domain Name System 즉 DNS는 도메인 이름을 IP 주소로 변환하는 시스템입니다. 먼저 사용자가 웹 브라우저에 google.com을 입력하면 먼저 로컬 DNS 캐시를 확인합니다. 캐시에 없으면 Internet Service Provider 즉 ISP의 리졸버 DNS 서버로 요청합니다. 리졸버는 루트 네임서버, TLD 네임서버, 권한 네임서버를 차례대로 조회해 최종 IP주소를 얻습니다. 이렇게 변환된 IP 주소가 응답으로 반환되면 웹 브라우저가 해당 IP주소로 접속합니다.
## DNS가 동작하는 과정을 설명해주세요
    DNS는 계층적으로 동작합니다. 루트 네임서버, TLD 네임서버, 권한 네임서버 순으로 작동하는데, 먼저 루트 네임서버에서 .com과 같은 TLD 네임서버를 알려주면 TLD 네임서버에서는 google.com의 권한 네임서버 정보를 제공합니다. 그리고 권한 네임서버는 최종적으로 해당 도메인의 IP 주소를 반환합니다.
## Cookie와 Session에 대해서 설명해주세요
    쿠키는 클라이언트에 저장되는 작은 데이터로 사용자의 상태를 유지하는 데 사용됩니다. 반면 세션은 서버 측에서 관리되며, 사용자와 서버 간의 연결 상태를 저장합니다. 쿠키는 브라우저가 요청을 보낼 때마다 서버에 함께 전달되고, 세션은 서버에서 세션 ID를 발급하고 이를 클라이언트의 쿠키에 세션 ID를 저장해서 식별합니다. 일반적으로 보안이 필요한 정보는 세션으로 서버에서 관리하고, 다크 테마 여부, 장바구니와 같이 보안이 크게 중요하지 않으면서 장기적인 상태 유지가 필요한 경우에는 쿠키를 사용합니다.
## 쿠키의 동작 방식에 대해서 설명해주세요
    쿠키는 HTTP 응답의 Set-Cookie 헤더를 통해 클라이언트에 저장됩니다. 이후 클라이언트는 쿠키 요청 시 Cookie 헤더에 쿠키를 포함해 서버로 보냅니다.
## 쿠키는 언제 사용할까요?
    쿠키는 로그인 유지나 장바구니 기능, 다크 모드와 같은 사용자 선호 설정, 광고 및 트래킹 등에 사용됩니다. 예를 들어 사용자가 로그인했을 때 서버는 세션ID를 가진 쿠키를 설정해 클라이언트에 저장하도록 해 인증 상태를 유지하도록 할 수 있습니다.
## 세션의 동작 방식에 대해서 설명해주세요
    세션은 서버에서 사용자의 상태를 저장하는 방식입니다. 예를 들어 클라이언트가 로그인하면 서버에서는 로그인 정보에 대한 세션 ID를 생성하고 식별을 위해 세션 ID를 포함한 쿠키를 저장하도록 합니다. 이후 클라이언트가 요청할 때마다 세션 ID를 포함하면 서버는 해당 세션 ID로 저장된 정보를 조회해 사용자의 상태를 유지할 수 있습니다. 하지만 세션은 정보를 서버 측에 저장하므로 메모리 등의 부담이 갈 수 있어서 일정 시간이 지나면 만료되거나 사라질 수 있습니다.
## 쿠키와 세션의 장단점은?
    쿠키는 클라이언트 측에 저장되기 때문에 서버에 부담이 적게 갑니다. 하지만 서버에 정보를 저장하는 것에 비해 보안이 취약하고 4KB의 크기 제한이 있습니다. 세션은 서버에서 관리되므로 보안성이 높아 중요한 정보를 저장할 수 있습니다. 하지만 서버의 메모리를 사용하므로 많은 사용자가 몰리는 서비스에서는 부담이 커질 수 있습니다.
## 만약 session의 값을 가져오는 key를 "user"라고 합시다, 사용자 A가 접속해도, B가 접속해도 "user"라는 key를 통해 가져오는데 어떻게 각각 다른 결과 값을 받을 수 있는지 설명해주세요.
    요청하는 사용자의 세션에 따라 컨텍스트가 달라지므로 같은 user 키 값이라고 하더라도 결과를 다르게 받을 수 있습니다.
## Session은 서버에 저장되고, Cookie는 클라이언트에 저장되는데, 쿠키가 안되는 상황에서 세션은 사용할 수 있을까요?
    예를 들어 보안 정책 상 쿠키를 사용할 수 없는 상황이다, 라고 하더라도 세션을 유지할 수는 있습니다. 이를 위해 로컬 스토리지나 URL에 세션ID를 포함하는 식으로 우회할 수는 있을 것 같습니다. 하지만 보안 상 좋지는 않으니 전자의 방식이 더 낫겠네요.
## 토큰 기반 인증 방식은 무엇인가요?
    토큰 기반 인증 방식은 서버에서 JWT 토큰이나 OAuth토큰을 받아 일정 기간 인증받는 방식입니다. 놀이공원 자유이용권 티켓 같은 개념으로 해당 날짜가 지나면 사용할 수 없지만, 허가받은 기간 안에는 무한정 인증받을 수 있는 시스템입니다.
## 장단점은?
    한번 줘버리면 끝이기 때문에 서버에 상태를 저장할 필요가 없는 장점이 있지만, 아무래도 토큰이 탈취되는 경우 악용될 여지가 있기 때문에 토큰 검증과 같은 방식으로 신중하게 사용해야 합니다.
## JWT는 무엇인가요?
    JSON Web Token즉 JWT는 JSON 형식으로 구성된 토큰 기반 인증 방식입니다. 일반적으로 헤더, 페이로드, 서명 세 부분으로 구성되며 서명을 이용해 무결성을 검증할 수 있습니다. JWT는 인증, 권한 부여, 정보 교환 등에 사용됩니다.
## JWT 구조에 대해서 말해주세요
    JWT는 크게 헤더, 페이로드, 서명으로 구성됩니다. 헤더는 토큰 타입과 해싱 알고리즘에 대한 정보를 담고 있습니다. 페이로드는 실제 정보가 들어가는 공간으로 사용자의 정보와 클레임 등이 포함됩니다. 마지막으로 서명은 무결성을 검증하기 위해 비밀키나 공개키를 사용해 서명된 값입니다.
## JWT의 단점은?
    JWT는 한번 발급되면 서버에서 조치할 수 있는 방법이 많지 않아 세션에 비해서 실시간 상태 변경이 어렵습니다. 또한 토크 크기가 커지면 네트워크 비용이 증가하며 토큰이 탈취되면 유효기간 내 악용될 여지가 있습니다.
## OAuth란 무엇인가요?
    Open Authorization 즉 OAuth는 타사 애플리케이션이 사용자 인증 없이 접근할 수 있도록 허용하는 표준 프로토콜의 일종입니다. 대표적으로 OAuth 2.0이 사용되며 액세스 토큰을 발급해 리소스 접근을 관리합니다.
## HTTP는 무엇인가요?
    HyperText Transfer Protocol즉 HTTP는 클라이언트와 서버 간 데이터를 주고받는 프로토콜입니다. Stateless하며 Connectionless합니다. 
## HTTP Header는 무엇이고, 어떤 종류가 있는지 설명해주세요
    HTTP 헤더는 요청과 응답에 대한 추가적인 정보를 제공하는 메타데이터입니다. 주요 유형으로는 User-Agent, Authorization, Set-Cookie, Cache-Control, Content-Type, Content-Length 등등이 있습니다.
## HTTP와 HTTPS의 차이는?
    평문으로 데이터를 전송하는 HTTP의 기존 방식에서 보안을 강화하기 위해 SSL/TLS 암호화 사용하는 방식이 HTTPS입니다. HTTPS는 중간자의 공격을 방지하고 데이터의 무결성을 보장합니다.
## SSL Handshake에 대해서 설명해주세요
    SSL 핸드쉐이크는 클라이언트 측 브라우저와 웹 서버가 서로 암호화 통신을 시작할 수 있도록 필요한 정보를 서로 주고 받는 과정입니다. 우선 TCP 연결을 위한 3-way 핸드쉐이크 이후에 서버가 HTTPS를 사용하는 것을 알게 되면 브라우저는 서버 측에 Client Hello를 보냅니다. 서버는 다시 서버의 공개키가 담긴 SSL인증서를 Server Hello단계에서 보냅니다.브라우저는 다시 SSL인증서가 믿을만한지 확인한 후 자신이 생성한 난수와 서버가 보낸 난수를 조합해 Premaster Secret을 만들어 보냅니다. 그럼 서버는 사이트의 비밀키를 사용해 Premaster Secret을 복호화합니다. 이렇게 되면 SSL 핸드쉐이크 과정이 종료되고 HTTPS 프로토콜을 통해 정보를 주고받을 수 있습니다.
## HTTP Request Method는 무엇이고 어떤 종류가 있는지 설명해주세요
    대표적으로 GET, POST, PUT, DELETE, PATCH, OPTIONS, HEAD 등이 있습니다.
## GET과 POST의 차이점은?
    GET을 데이터를 가져오기 위해 사용하며 URL에 데이터가 포함됩니다. POST는 데이터를 서버로 전송하는 데 사용되며, Body에 데이터를 포함해 보안성이 높습니다.
## HTTP Response Status Code는 무엇이고 어떠한 종류가 있는지 설명해주세요
    HTTP 응답 상태 코드라고 하며, 2xx는 성공, 3xx는 리다이렉션, 4xx는 클라이언트측 오류, 5xx는 서버측 오류 등으로 분류됩니다.
## HTTP 세션 유지란 무엇이고, 여러 서버가 존재할 때 세션을 어떻게 유지할 수 있을까요?
    HTTP는 Stateless하기 때문에 사용자의 상태를 유지하기 위해서는 세션을 유지해야 합니다. 여러 서버가 존재하는 경우에는 같은 사용자의 요청을 항상 같은 서버로 보내도록 하는 스티키 세션이나 Redis나 Memcached같은 중앙 저장소를 가운데 두고 세션을 저장한 뒤 여러 서버에서 공유하도록 할 수도 있습니다. 아니면 JWT같은 방법을 사용해도 될 것 같습니다.
## 멱등성에 대해 설명하고, HTTP 메소드에서는 어떤 메소드가 멱등성 메소드인지 설명해주세요
    멱등성이란 같은 요청을 여러 번 보내도 결과가 변하지 않는 성질을 말합니다. HTTP에서는 데이터를 조회하는 GET, 수정 정보를 전부 바꾸는 PUT, id를 지정해서 삭제하는 DELETE 등이 있습니다. HEAD, OPTIONS, TRACE등도 멱등성을 가집니다. 하지만 POST는 여러 번 요청하면 새로운 데이터가 생성될 수 있습니다.
## HTTP의 Keep-alive 헤더에 대해 설명해주세요.
    Keep-alive는 클라이언트와 서버 간의 연결을 지속하는 HTTP 헤더입니다. HTTP 1.0에서는 기본적으로 요청이 끝날 때 연결이 닫히므로 Connection: keep-alive헤더를 사용해야 지속적으로 연결을 유지할 수 있습니다. 하지만 HTTP 1.1에서는 Keep-alive가 기본값이므로 여러 요청을 동일한 TCP 연결에서 처리할 수 있습니다. TCP 핸드쉐이크 비용을 줄이고 성능을 최적화하는 방법이 될 수 있습니다.
## HTTP 1.0 vs HTTP 1.1 vss HTTP 2.0을 각각 비교하여 설명해주세요.
    HTTP 1.0은 요청마다 새로운 연결을 열어야 해서 비효율적입니다. HTTP 1.1은 Keep-alive가 기본값으로 적용돼 성능이 향상됩니다. 헤더 크기도 1.0에 비해서 최적화되어 있습니다. 그리고 HTTP 2.0은 하나의 연결에서 여러 요청을 동시에 처리할 수 있는 멀티플렉싱, 헤더 압축, 서버 푸시 등이 적용돼 더 빠른 속도를 제공할 수 있습니다.
## REST API에 대해 설명해주세요
    REST API는 HTTP기반의 리소스 중심 아키텍처 스타일입니다. 각 자원들이 URI를 통해 식별되며, CRUD 작업을 HTTP 메서드로 처리합니다.
## CORS는 무엇인가요?
    CORS는 다른 도메인 간에 요청을 허용하는 정책입니다. 기본적으로 브라우저에서는 Same-Origin Policy가 적용돼 다른 도메인의 요청이 차단됩니다. 이를 해결하기 위해 서버는 Access-Control-Allow-Origin헤더를 설정해 특정 도메인의 요청을 허용할 수 있습니다. 명시적으로 허용하지 않는 이상 최대한 차단하는 보안 방식입니다.
## URI와 URL이 무엇이 다른지 설명해주세요
    URI는 Uniform Resource Identifier로 자원을 식별할 수 있는 모든 문자열을 뜻하고, URL은 Uniform Resource Locator로 리소스의 위치를 포함하는 URI의 일부 종류입니다. 