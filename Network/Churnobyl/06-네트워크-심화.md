# 네트워크 심화

# 안정성을 위한 기술

## 가용성

- **가용성(Availability)**은 안정성의 정도를 나타내는 용어로 **고가용성(High Availablity)**라는 용어가 있습니다.
- 가용성은 컴퓨터 시스템이 특정 기능을 실제로 수행할 수 있는 시간의 비율
- 업타임 : 정상적인 사용 시간
- 다운타임 : 정상적인 사용이 불가능한 시간
- 가용성 = 업타임 / (업타임 + 다운타임)
- 일반적으로 안정적이라고 평가받는 시스템은 가용성이 99.999% 이상을 목표로 함. 이는 **파이프 나인스**라도고 함
- 서비스가 다운되는 원인은 다양하므로 발생 원인을 모두 찾아 원천적으로 차단하기는 현실적으로 어려움
- 따라서 문제가 발생하더라도 기능할 수 있도록 설계해야 하는데 이러한 능력을 **결함 감내 (Fault tolerance)**라고 함

## 이중화

- 이중화는 무언가를 이중으로 두는 기술
- 결함을 감내해 가용성을 높이기 위한 가장 기본적이고 대표적인 방법
- 이중화할 수 있는 대상은 다양한데, 서버 컴퓨터, 네트워크 인터페이스(NIC), 스위치와 같은 물리적인 장비뿐만 아니라, 데이터베이스, 웹 서버 등도 이중화할 수 있는 대상임
- 이중화할 수 있는 대상은 대부분 문제가 발생할 경우 시스템 전체가 중단될 수 있는 대상들임
- **단일 장애점**(SPoF; Single Point Of Failure) : 문제가 발생할 경우 시스템 전체가 중단될 수 있는 대상
- 이중화 구성에는 **액티브/스탠바이**(Active-standby), **액티브/액티브**(Active-active)가 있음
- 액티브/스탠바이는 한 시스템은 가동하고, 다른 시스템은 백업 용도로 대기 상태로 두는 이중화 구성 방식
- 액티브/액티브는 두 시스템 모두를 가동 상태로 두는 구성 방식
- 이중화를 확장하면 여러 개를 두는 기술로 **다중화**가 있음
- 이중화/다중화 사례로 윈도우의 **티밍(Teaming)**, 리눅스의 **본딩(Bonding)**이 있음

## 로드 밸런싱

- 트래픽의 사전적인 정의는 주어진 시점에 네트워크를 경유한 데이터의 양
- 일반적으로 트래픽의 측정은 노드에서 이루어지므로 주어진 시점에 특정 노드를 경유한 패킷의 양으로도 볼 수 있음
- 과도한 트래픽은 서버의 가용성을 떨어뜨릴 수 있어 서버를 다중화했더라도 트래픽을 고르게 분산해야 함
- 트래픽의 고른 분배를 위해 사용되는 기술이 **로드 밸런싱**(Load Balancing)
- 로드 밸런싱은 로드 밸런서(Load Balancer)에 의해 수행됨
- L4 스위치, L7 스위치라고 불리는 네트워크 장비로도 로드 밸런싱을 수행할 수 있지만 HAProxy, Envoy, Nginx같은 소프트웨어로도 수행할 수 있음
- 로드 밸런싱 알고리즘의 종류는 **라운드 로빈 알고리즘**(Round-Robin), **최소 연결 알고리즘**(Least Connection), **가중치 라운드 로빈 알고리즘**(Weighted Round-Robin), **가중치 최소 연결 알고리즘**(Weighted Least Connection)이 있음.

# 안전성을 위한 기술

## 암호와 인증서

### 대칭 키 암호화(Symmetric key cryptography)

- 대칭 키 암호화 방식에서는 암호화와 복호화에 동일한 키를 사용
- 상대방에게 안전하게 키를 전달하기 어려움
- 암호화와 복호화에 동일 한 키를 사용하므로 키가 유출되면 문제가 발생

### 공개 키 암호화(Public key cryptography)/비대칭 키 암호화(Asymmetric key cryptography)

- 대칭 키 암호화와는 달리 암호화를 위한 키와 복호화를 위한 키가 다름
- 한 키로 암호화했다면 다른 키로 복호화할 수 있음
- 이 한 쌍의 키를 **공개 키**(Public key), **개인 키**(Private Key)라고 부름
- A, B가 있을 때 A가 B에게 C를 안전하게 전송하고 한다면 먼저 A가 B에게 B의 공개 키를 요청함. 그리고 B의 공개 키로 C를 암호화한 뒤 B에게 전달함. B는 B의 개인 키로 C를 복호화함
- 대칭 키 암호화는 적은 부하 덕분에 암호화/복호화를 빠르게 할 수 있지만, 상대적으로 공개 키 암호화는 시간과 부하다 더 듬

### 인증서와 디지털 서명

- **공개키 인증서**(Public key certificate)는 공개 키와 공개 키의 유효성을 입증하기 위한 전자 문서
- 이러한 인증서는 **인증 기관**(CA; Certification Authority)라는 제3의 기관에서 발급함
- CA가 발급한 인증서에는 공개 키 인증서의 진위를 증명하는 **서명 값**(Signature)이 있음
- 서명 값은 인증서 내용에 대한 해시 값을 CA의 개인 키로 암호화하는 방식으로 만들어짐
- CA는 서명 값과 인증서를 클라이언트에게 전송함
- 클라이언트는 서명 값을 CA의 공개 키로 복호화하고, 또 인증서 내용에 대한 해시 값을 직접 구해서 해싱함
- 두 값이 같으면 CA의 개인 키로 만들어진 것을 보장함

### HTTPS: SSL과 TLS

- SSL/TLS를 사용하는 대표적인 프로토콜은 HTTPS(HTTP Secure)임
- HTTPS 메시지는 다음과 같이 TCP 쓰리 웨이 핸드셰이크, TLS 핸드셰이크, 암호화된 메시지 송수신 세 단계로 전송됨
- TLS 핸드셰이크에서는 다음과 같은 과정을 거침
- 클라이언트가 먼저 지원되는 TLS버전, 사용 가능한 암호화 방식, 해시 함수, 키를 만들기 위해 사용할 클라이언트의 난수 등이 포함된 **암호 스위트**(Cipher suite)를 Client Hello 메시지에 담아 보냄
- 서버는 클라이언트가 보낸 암호 스위트에서 사용할 정보들을 선택함
- 선택된 TLS 버전, 암호 스위트 정보, 키를 만들기 위해 사용할 서버의 난수 등을 Server Hello 메시지로 보냄
- 이후 서버가 Certificate메시지, CertificateVerify메시지를 보내면 클라이언트는 이 메시지를 토대로 서버의 공개 키를 검증함
- 최종적으로 Finished 메시지를 주고받으면 얻은 키를 기반으로 암호화된 데이터를 주고 받음