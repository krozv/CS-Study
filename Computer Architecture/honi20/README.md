# 기출 질문

[참고](https://velog.io/@rlagurwns112/%EC%BB%B4%ED%93%A8%ED%84%B0-%EA%B5%AC%EC%A1%B0-%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8-%EC%A0%95%EB%A6%AC)

### 💡 시스템 소프트웨어와 응용 소프트웨어의 차이를 설명하시오

시스템 소프트웨어는 운영체제, 컴파일러 같이 사용자들이 컴퓨터를 효율적으로 사용할 수 있게 도와주는 소프트웨어 입니다.

응용소프트웨어는 특정 목적을 달성하기 위해 만들어진 프로그램입니다.

### 💡 시스템 버스란?

시스템 버스는 하드웨어 각각의 구성요소 간 데이터 통신을 위해 필요한 통로입니다. 용도에 따라 데이터 버스, 주소 버스, 제어 버스로 나누어집니다.

데이터 버스는 CPU와 기타 장치 사이에서 데이터를 전송하기 위한 버스입니다.

주소 버스는 데이터를 전송하기 위해 주소를 전달하는 버스이고 CPU에서 주기억장치, 입출력장치로 향하는 단방향 버스입니다.

제어버스는 CPU가 기억하거나 입출력 장치에 제어 신호를 전달하기 위해 필요한 버스입니다.

제어 신호의 종류는 인터럽트 요청, 기억장치 쓰기와 읽기, 버스 사용 요청등이 있습니다.

### 💡 명령어 처리 과정에 대해 설명하시오

명령어 처리 과정은 인출 사이클과 실행 사이클 두개로 나누어집니다. 인출 사이클은 PC에 저장된 주소를 메모리 주소 레지스터에 저장하고 PC값을 1 증가시킵니다. 그리고 명령어를 명령어 레지스터에 전달하면 인출 사이클이 완료됩니다. 실행 사이클은 데이터를 인출하고 데이터 처리 그리고 처리된 데이터를 저장하는 과정을 거쳐서 완료됩니다.

### 💡 RISC와 CISC의 차이를 설명하시오

RISC는 단순한 명령어의 조합으로 이루어져 있어서 설계가 간단하고 비용이 줄어듭니다. 따라서 복잡한 명령어를 소프트웨어적으로 구현해야 하므로 부담이 상대적으로 큽니다. 보통 안드로이드에서 사용됩니다.

CISC는 복잡한 명령어들로 구성되어 있습니다. 명령어 해석에 시간이 필요하고 회로도 상대적으로 복잡합니다. 주로 윈도우 환경에서 사용됩니다.

### 💡 파이프라이닝란?

명령어를 처리할때 한번에 하나씩 순차적으로 처리하는 것이 아니라 명령어가 처리되는 도중에 다른 명령어의 처리를 시작하는 방식으로 **동시에 여러개의 명령어를 처리**해 **처리량**을 올리는 것입니다.

명령어의 처리시간을 단축시키는 것이지 동작속도를 증가시키는 것은 아닙니다.

이때 **처리시간**과 **처리단계**가 균등하지 않아서 **‘해저드’** 라는 오류가 발생할수 있습니다.

### 💡 해저드란?

**해저드**란 파이프라이닝에서 나타나는 문제점을 뜻합니다. 명령어의 처리시간과 처리단계가 균등하지 않아서 발생합니다.

해저드의 종류는 **구조적 해저드**, **데이터 해저드**, **제어 해저드**로 나뉩니다.

- 구조적 해저드  
  **구조적 해저드**는 하나의 자원을 여러개의 명령어에서 동시에 사용하려 할 때 발생합니다. 구조적 해저드를 해결하기 위해서는 데이터 처리와 명령어 처리를 동시에 할 수 있게 **자원을 추가**하거나 **명령어 처리를 지연**시켜서 해결합니다.
- 데이터 해저드  
  **데이터 해저드**는 **이전 명령어의 결과값**이 다음 명령어의 **입력으로 사용**될 경우 발생합니다.이를 해결하기 위해 **결과를 저장하기 전에 다음 명령어를 입력**으로 넣어줘서 해결하거나 이전 명령어의 값이 저장되기 전까지 기다렸다가 진행하는 방식을 사용합니다.
- 제어 해저드  
  **제어 해저드**는 분기처리시 다음 명령어가 어떤 것인지 **특정하지 못하기** 때문에 발생합니다.이를 해결하기 위해 **분기 처리에 영향을 받지 않는 명령어를 우선 수행**하거나 **명령어 분기를 예측**하여 명령어를 수행하거나 **지연**시키는 방법으로 해결합니다.

### 💡 파이프라이닝을 사용하는 이유는?

파이프 라이닝 구조는 한 번에 하나의 명령어 처리가 아니라 하나의 명령어가 실행 되는 도중에 다른 명령어도 실행하여 각 단계에 있는 자원들을 놀리지 않고 역할을 부여함으로써 동시에 여러 개의 명령어를 처리할 수 있게 합니다. 이것은 처리량을 늘리기 때문에 동일 시간에 더 많은 명령어를 처리할 수 있기 때문에 효율적이라고 할 수 있습니다.

### 💡 캐시메모리란?

캐시메모리는 속도가 빠른 장치와 느린 장치 사이의 병목현상을 줄이기 위한 메모리입니다. 메인메모리와 CPU사이에서 자주 사용되는 데이터를 캐시에 저장해서 사용해서 속도를 향상시킵니다. 캐시 적중률을 높이기 위해 참조 지역성의 원리를 사용합니다. 이 원리는 한번 캐싱된 데이터를 다시 참조될 가능성이 높다고 생각하는 시간 지역성과 참조된 데이터 주변의 데이터가 참조될 가능성이 높다고 생각하는 공간지역성을 바탕으로 합니다.

### 💡 HDD와 SSD의 차이를 설명하시오

HDD는 하드디스크라고 불리며 회전하는 자기 디스크와 읽기,쓰기 헤드로 구성되어있습니다. 기계적 움직임 때문에 속도가 느리고 충격에 약합니다. 가격은 상대적으로 저렴하고 일반적으로 더 큰 용량을 제공합니다.

SSD는 보통 NAND 플래시 메모리로 구성된 장치입니다. 속도는 빠르며 충격에 강합니다. 가격은 비싸고 동일 가격대중에서 용량은 작습니다.

### 💡 CPU란?

CPU는 컴퓨터의 중앙 처리 장치입니다. ALU, CU, 레지스터, 캐시 메모리로 구성되어 있습니다. ALU는 산술 및 논리 연산을 수행하는 장치이며 CU는 명령어를 해석하고 실행을 제어합니다. 레지스터는 고속 메모리로 데이터를 일시적으로 저장합니다. 캐시 메모리는 고속 데이터 접근을 위한 메모리입니다.

### 💡 GPU란?

GPU는 그래픽 및 이미지 처리를 전담하는 프로세서입니다. 대규모 병렬 처리를 통해 그래픽 렌더링과 이미지 처리를 가속화하며 게임,그래픽 디자인,인공지능 모델 학습 등에 사용됩니다.

### 💡 슈퍼스칼라란?

슈퍼스칼라는 한 사이클에 여러 명령어를 동시에 처리하는 CPU 아키텍처입니다. 명령어 처리 성능을 향상시키기 위해 만들어졌으며 복수의 실행 유닛을 사용하여 명령어를 병렬로 실행합니다. 파이프라인 기법은 하나의 코어에 여러 개의 스레드를 사용하는 방법인 반면, 슈퍼스칼라 기법은 코어를 여러개 구성하여 복수의 명령어를 동시에 실행하는 방식입니다.

### 💡 메모리 계층 구조를 설명하시오

메모리 계층은 속도와 용량에 따라 메모리를 계층화한 구조입니다.
레지스터는 가장 빠르고 작은 메모리입니다.
캐시 메모리는 CPU와 RAM 사이에 위치하고 있습니다.
주 메모리는 휘발성 메모리로 실행 중인 프로그램과 데이터를 저장합니다.
보조 저장 장치는 비휘발성 메모리로 데이터를 영구적으로 저장합니다.

### 💡 컴파일러와 인터프리터를 각각 설명하시오

컴파일러와 인터프리터는 소스코드를 해석하고 실행시키는 방식입니다.

컴파일러는 소스코드가 실행되기 전에 기계어로 변환 및 해석하는 방식으로 소스코드에 문제가 있다면 실행되지 않고 오류를 알립니다.

반면 인터프리터는 소스코드가 먼저 실행된 다음에 코드를 한 줄씩 변환 및 해석하며 소스코드에 문제가 있기 전까지 실행됩니다.

### 💡 메모리의 구조에 대해 설명하시오

메모리의 구조는 데이터 영역, 스택 영역, 힙 영역, 코드 영역으로 구성되어 있습니다.

데이터 영역은 전역변수와 정적 변수가 저장되는 공간이고, 스택 영역은 함수 호출시 지역 변수와 매개변수가 저장되는 공간입니다. 힙 영역은 동적 메모리 할당 시 사용되는 메모리 영역입니다. 코드 영역은 프로그래머가 작성한 프로그램이 저장되는 공간입니다.

코드 영역과 데이터 영역은 프로세스가 실행되기 직전에 위치와 크기가 결정되고 실행되는 동안 변하지 않는 정적 할당 구역입니다. 힙 영역과 스택 영역은 프로세스가 실행되는 동안 만들어지는 영역으로 동적으로 변합니다.

### 💡 고정 소수점과 부동 소수점을 각각 설명하시오

고정 소수점은 10진수를 2진수로 변경해서 사용하는 방식입니다. 부호부,정수부,소수부로 나누어서 표현합니다.

부동 소수점은 2진수로 변경한 값을 그대로 사용하는 것이 아니라 정규화의 과정을 거친 후 부호부, 지수부, 가수부로 나누어서 표현합니다. 가수는 실수의 실제 값이며, 지수부의 지수 값에 따라 소수점이 움직이는 방식을 활용한 실수 표현법입니다.

### 💡 패리티 비트와 해밍 코드

패리티 비트는 정보 전달 과정에서 오류의 여부를 검사하기 위해 데이터 각 문자에 1비트를 추가해 전송합니다. 종류는 짝/홀수가 있으며 전체 비트에 짝수/홀수에 맞게 비트를 정합니다.

해밍 코드는 데이터 전송시 1비트의 에러를 정정할 수 있는 자기 오류정정 코드입니다. 패리티 비트를 보고 1비트에 대한 오류를 정정할 곳을 찾아 수정합니다. 패리티 비트는 오류를 검출만 하고 해밍코드는 오류를 수정합니다.
