# 중앙처리장치(CPU) 작동 원리

컴퓨터의 두뇌  
**메모리에 저장된 명령을 읽고 해석하고 실행함**  
종류는 크게 `ALU(Arithmetic Logic Unit)`, `레지스터(Register)`, `제어 장치(Control Unit)`으로 나뉨

## ALU

계산만을 위해 존재하는 부품  
내부에서 수행되는 **대부분의 계산을 도맡음**  
레지스터로부터 **피연산자**를, 제어장치로부터 **수행할 연산을 알려주는 제어신호**를 받아 연산을 수행함  
이후 **연산 결과**와 **플래그**를 내보냄

- **플래그**  
  연산 결과에 대한 추가적인 상태 정보

| 플래그 이름                     | 역할                                               |
|----------------------------|--------------------------------------------------|
| 부호 플래그(Sign Flag)          | 음수면 1, 양수면 0                                     |
| 제로 플래그(Zero Flag)          | 결과가 0이면 1, 아니면 0                                 |
| 캐리 플래그(Carry Flag)         | 최상단 비트에서 자리 올림 발생 시 1, 아니면 0                     |
| 오버플로우 플래그(Overflow Flag)   | 최대 표현 숫자를 넘기거나, 같은 부호를 더했을때 결과가 다른 부호일시 1, 아니면 0 |
| 인터럽트 플래그(Interrupt Flag)   | CPU가 인터럽트가 가능하면 1, 불가능하면 0                       |
| 슈퍼바이저 플래그(Supervisor Flag) | 커널모드로 실행중이면 1, 사용자 모드로 실행중이면 0                   |

> **캐리 플래그, 오버플로우 플래그가 햇갈린다면?**  
> 4bit 연산을 가정
> - 1111 + 0001 = 10000  
    최상단 비트에서 자리 올림이 발생했으므로 캐리 플래그 set  
    4bit 이므로 1이 무시되지만 하위 4bit 가 알맞은 값을 표현하고 있으므로 오버플로우 플래그 x
> - 0111 + 0001 = 1000  
    7 + 1의 연산 결과가 최대 표현 숫자를 넘겨 -8이 나왔으므로 오버플로우 플래그 set

## Register

프로그램을 실행하는 데 **필요한 값을 임시로 저장**함  
여러 레지스터가 존재하며 각자 다른 이름과 역할을 가지고 있음  
대표적으로 8개의 레지스터 종류가 있음

- **프로그램 카운터**  
  메모리에서 가져올 명령어의 주소를 저장  
  그래서 명령어 포인터라고 부르기도 함
- **명령어 레지스터**  
  방금 메모리에서 읽어들인 명령어를 저장  
  제어장치는 여기서 명령어를 꺼내씀
- **메모리 주소 레지스터**  
  메모리의 주소를 저장  
  읽어 들이려는 주소 값을 주소 버스로 보낼 때 사용
- **메모리 버퍼 레지스터**  
  메모리와 주고받을 데이터와 명령어를 저장  
  데이터 버스를 통해 오고 가는 값이 거쳐감
- **플래그 레지스터**  
  연산 결과 또는 CPU 상태에 대한 플래그를 저장
- **누산기**  
  데이터를 일시적으로 저장하는 레지스터
- **범용 레지스터**  
  진짜 암거나 됨
- **스택 포인터**  
  스택의 꼭대기를 저장
  스택 주소 지정 방식에서 사용
    - 스택 주소 지정 방식  
      메모리 스택 영역에서 스택과 스택 포인터를 사용해 주소를 지정
- **베이스 레지스터**  
  기준 주소를 저장  
  변위 주소 지정 방식에서 사용
    - 변위 주소 지정 방식  
      그냥 `../` `./` 같은 상대 주소 생각하면 편함  
      베이스 레지스터에 저장된 기준 주소 기준으로 어느 위치에 있는지 저장하게 됨

## Control Unit

`제어 신호(Control Signal)`을 내보내고 명령어를 해석함  
대충 컴퓨터 부품들을 관리하고 작동시키는 신호

# CPU 동작 과정

## 명령어 사이클

각 명령어들이 일정한 주기가 반복되면서 실행됨

1. 인출 사이클  
   메모리에서 CPU로 명령어를 가져옴  
   <img src="https://github.com/user-attachments/assets/ddfab5fa-5d39-49ed-aa5f-30de2acd3b9d" width="400" alt="인출 사이클 이미지">
    ```
    T0 : MAR <- PC (PC에 있는 주소를 MAR로 전달)
    T1 : MBR <= M[MAR] (MAR 주소에 있는 명령어를 가져와 MBR로 전달), PC <= PC + 1 (PC 증가)
    T2 : IR <- MBR (MBR에 있는 명령어를 IR로 전달)
    ```
2. 실행 사이클  
   가져온 명령어를 실행함  
   여기서 CU가 IR에 담긴 명령어 해석 및 제어 신호 발생  
   <img src="https://github.com/user-attachments/assets/a3201247-67c9-4dcd-a427-3721f88a534c" width="400" alt="이미지">   
   크게 데이터 이동, 데이터 처리, 데이터 저장, 프로그램 제어를 함

    - 데이터 이동  
      `IR`에 저장된 명령어의 operand로 메모리에서 데이터 인출  
      <img src="https://github.com/user-attachments/assets/dc871367-08b8-425f-bb96-92a18a781fb7" width="600" alt="이미지">
      ```
      T0 : MAR ← IR(Addr) (IR에 있는 operand 주소를 MAR로 전달)
      T1 : MBR ← M[MAR] (해당 주소로부터 데이터를 가져와 MBR로 전달)
      T2 : AC ← MBR (해당 데이터를 AC로 전달)
      ```
    - 데이터 처리  
      기억장치에 저장된 데이터를 AC의 데이터와 더하고 다시 `AC`에 저장  
      <img src="https://github.com/user-attachments/assets/2bd1ecad-67b1-4c31-a2e9-a0dff48de026" width="600" alt="이미지">
      ```
      T0 : MAR ← IR(Addr) (IR에 있는 operand 주소를 MAR로 전달)
      T1 : MBR ← M[MAR] (해당 주소로부터 데이터를 가져와 MBR로 전달)
      T2 : AC ← AC + MBR (해당 데이터를 AC와 더함)
      ```
    - 데이터 저장  
      `AC`의 데이터를 메모리에 저장  
      <img src="https://github.com/user-attachments/assets/42f187d4-df3d-47ed-884d-f03ca2417641" width="600" alt="이미지">
      ```
      T0 : MAR ← IR(Addr) (저장할 주소를 MAR로 전달)
      T1 : MBR ← AC (AC에 있는 데이터를 MBR로 전달)
      T2 : M[MAR] <- MBR (MAR의 주소로 MBR 데이터 전달)
      ```
